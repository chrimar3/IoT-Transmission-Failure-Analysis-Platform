# Story 4.2: Professional API Access

## Status
Draft

## Story
**As a** systems integrator,  
**I want** API access  
**so that** I can integrate building analytics into existing facility management systems

## Acceptance Criteria

### AC1: RESTful API with Comprehensive Documentation
- Complete API documentation with endpoint specifications, request/response schemas, and authentication details
- Interactive API documentation interface (Swagger/OpenAPI) for testing and exploration
- Professional tier API access integrated with subscription validation middleware
- Comprehensive error handling with standardized error response formats
- API versioning strategy implemented for future-proof integrations
- Example request/response payloads for all endpoints with realistic Bangkok dataset data

### AC2: API Key Authentication for Professional Users
- API key generation and management interface for Professional tier subscribers
- Secure API key storage and validation system with encrypted keys in database
- API key rotation capability with deprecation notices and migration support
- Professional tier subscription validation on all API key operations
- API key scoping and permission management (read-only, full access levels)
- API key usage tracking and analytics for monitoring and billing purposes

### AC3: Rate Limiting Appropriate to Subscription Tier
- Professional tier rate limiting: 10,000 requests/hour with burst capability
- Free tier rate limiting: 100 requests/hour for basic endpoint access
- Rate limit headers in API responses (X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset)
- Rate limit monitoring and alerting when users approach their limits
- Graceful rate limit handling with informative error messages and retry guidance
- Rate limit analytics dashboard for users to monitor their usage patterns

### AC4: JSON Responses with Consistent Schema
- Standardized JSON response format across all API endpoints with consistent field naming
- Comprehensive schema validation using Zod for all API inputs and outputs
- Bangkok dataset specific response schemas for sensor readings and analytics data
- Error response standardization with error codes, messages, and troubleshooting guidance
- API response field documentation with data types, constraints, and example values
- Pagination support for large datasets with cursor-based pagination for performance

### AC5: API Usage Analytics and Monitoring
- Real-time API usage tracking with endpoint-level metrics and response time monitoring
- User-specific API analytics dashboard showing usage patterns and performance metrics
- API performance monitoring with alerting for degradation or failures
- Usage quota tracking and automated notifications when approaching limits
- API endpoint performance analytics (P50, P95, P99 response times) for optimization
- Historical usage reporting for capacity planning and billing reconciliation

### AC6: Example Code and SDKs
- TypeScript/JavaScript SDK with full type definitions and error handling
- Python SDK for data science and analytics integration workflows
- cURL examples for all API endpoints with authentication and pagination
- Integration examples for common facility management systems (generic patterns)
- API client libraries with built-in retry logic and rate limit handling
- Comprehensive code examples repository with real-world integration scenarios

## Priority & Effort
**Priority**: P1 (Differentiation)  
**Effort**: 5 points  
**Epic**: 4 (MVP Completion)

## Tasks / Subtasks

### Task 1: API Documentation and Specification Creation (AC: 1, 4)
**Subtasks:**
1.1. Create OpenAPI 3.0 specification for all Professional API endpoints with complete schema definitions
1.2. Generate interactive API documentation using Swagger UI with live testing capability
1.3. Document all API endpoints with detailed request/response examples using Bangkok dataset
1.4. Create API authentication guide with step-by-step API key setup and usage instructions
1.5. Add API error handling documentation with error codes, causes, and resolution guidance
1.6. Implement API versioning documentation with migration guides and deprecation policies
1.7. Create comprehensive API testing suite validating all documented behaviors and edge cases

### Task 2: API Key Generation and Management System (AC: 2)
**Subtasks:**
2.1. Create API key database schema with encryption, scoping, and Professional tier validation
2.2. Implement secure API key generation with cryptographically secure random generation
2.3. Build API key management interface for Professional users with key creation and rotation
2.4. Add API key validation middleware for all protected API endpoints with performance optimization
2.5. Create API key scoping system for different permission levels (read-only, full access)
2.6. Implement API key rotation system with deprecation notices and transition periods
2.7. Add comprehensive API key security testing including key validation and scope enforcement

### Task 3: Professional Tier API Endpoints Implementation (AC: 1, 4)
**Subtasks:**
3.1. Implement core analytics API endpoints for sensor data retrieval and aggregation
3.2. Create time-series data API with filtering, pagination, and Bangkok dataset optimization
3.3. Add failure pattern analysis API with advanced analytics and trend identification
3.4. Implement data export API endpoints supporting multiple formats (JSON, CSV, Excel)
3.5. Create sensor metadata API for equipment information and floor layouts
3.6. Add real-time data streaming API endpoint using WebSocket or Server-Sent Events
3.7. Create comprehensive API endpoint testing including integration tests and performance validation

### Task 4: Rate Limiting and Quota Management (AC: 3)
**Subtasks:**
4.1. Implement tier-based rate limiting with Professional (10K/hour) and Free (100/hour) limits
4.2. Create rate limiting middleware with Redis caching for high-performance quota tracking
4.3. Add rate limit response headers and informative error messages for limit exceeded scenarios
4.4. Implement burst capability for Professional tier with short-term rate limit increases
4.5. Create rate limit monitoring and alerting system for usage pattern analysis
4.6. Add user-facing rate limit dashboard showing current usage and remaining quota
4.7. Create comprehensive rate limiting testing including load testing and quota accuracy validation

### Task 5: API Usage Analytics and Monitoring System (AC: 5)
**Subtasks:**
5.1. Implement real-time API usage tracking with endpoint-level metrics and response time monitoring
5.2. Create API analytics database schema with usage patterns, performance metrics, and error tracking
5.3. Build user-specific API analytics dashboard with usage charts and performance insights
5.4. Add API performance monitoring with automated alerting for response time degradation
5.5. Create usage quota tracking with automated notifications at 80% and 95% of limits
5.6. Implement historical usage reporting for capacity planning and billing reconciliation
5.7. Add comprehensive analytics testing including metric accuracy and dashboard functionality

### Task 6: SDK and Example Code Development (AC: 6)
**Subtasks:**
6.1. Create TypeScript/JavaScript SDK with comprehensive type definitions and error handling
6.2. Develop Python SDK with data science focused utilities and pandas integration
6.3. Generate cURL examples for all API endpoints with authentication and real Bangkok data
6.4. Create integration examples for common facility management system patterns
6.5. Build SDK testing suite with automated testing of all SDK methods and error scenarios
6.6. Create comprehensive code examples repository with real-world integration scenarios
6.7. Add SDK documentation and getting started guides with step-by-step integration tutorials

### Task 7: Subscription Integration and Access Control (AC: 2, 3)
**Subtasks:**
7.1. Implement Professional tier subscription validation for all API access points
7.2. Create subscription status checking middleware with caching for performance optimization
7.3. Add graceful degradation handling for expired subscriptions with appropriate error messages
7.4. Integrate API usage with Stripe billing for potential usage-based billing future expansion
7.5. Create subscription upgrade prompts within API responses for Free tier users
7.6. Add subscription-based feature flagging for different API endpoint access levels
7.7. Create comprehensive subscription integration testing including edge cases and billing scenarios

### Task 8: API Security, Performance, and Monitoring (AC: 1-6)
**Subtasks:**
8.1. Implement comprehensive API security with input validation, SQL injection prevention, and rate limiting
8.2. Add API performance optimization for Bangkok dataset queries with caching and query optimization
8.3. Create API monitoring dashboard with real-time performance metrics and error tracking
8.4. Implement API endpoint security testing including authentication bypass and injection attempts
8.5. Add API load testing to validate performance under high concurrent Professional user load
8.6. Create API error tracking and logging with Sentry integration for production monitoring
8.7. Add comprehensive API security and performance testing suite with automated validation

## Dev Notes

### Previous Story Insights
**From Story 4.1 Implementation (Custom Alert Configuration):** The Professional tier subscription validation middleware and authentication patterns provide foundation for API access control. Email service integration patterns and delivery confirmation tracking can inform API usage notification systems. Alert evaluation performance optimization techniques for Bangkok dataset scale will inform API endpoint query optimization. [Source: Previous story context from 4.1.custom-alert-configuration.md]

**From Story 3.4 Implementation (Data Export):** Data export API patterns and CSV/PDF generation functionality provide foundation for API data format responses. Professional tier access control and subscription validation middleware can be extended for API key authentication. Bangkok dataset query optimization and performance patterns inform API endpoint implementation. [Source: Previous story context from export functionality stories]

**From Dashboard Stories (3.1-3.3):** Real-time data visualization patterns and WebSocket connections provide foundation for real-time API endpoints. Sensor data filtering, aggregation, and time-series query patterns can be adapted for API response formats. Chart data processing and optimization techniques inform API response payload optimization. [Source: Previous story context from dashboard implementation]

### Production Readiness Requirements
**API Failure Handling:** [Source: architecture/8-api-architecture.md]
- API endpoints must implement exponential backoff retry logic for database connection failures
- API key validation failures require comprehensive error responses with troubleshooting guidance
- Service degradation during Supabase outages requires cached response serving with staleness indicators
- Rate limiting system must handle Redis connection failures gracefully with local fallback quotas

**Service Rate Limit Monitoring:** [Source: architecture/8-api-architecture.md]
- Supabase connection monitoring: 100 concurrent connections with API request throttling at 80% capacity
- Professional tier rate limits: 10,000 requests/hour with monitoring alerts at 80% and 95% usage
- Free tier rate limits: 100 requests/hour with upgrade prompts at 80% usage
- API performance monitoring with automated scaling alerts for response time degradation

**Performance Benchmarks:** [Source: architecture/10-monitoring-observability.md]
- API response times: <500ms average, <1s 95th percentile for all endpoints
- Bangkok dataset query performance: <100ms for simple queries, <1s for complex aggregations
- API key validation latency: <50ms with Redis caching optimization
- Documentation loading: <2 seconds for interactive API documentation interface

**Error Logging and Alerting:** [Source: architecture/10-monitoring-observability.md]
- Comprehensive error tracking with Sentry integration for API endpoint failures and security incidents
- API usage analytics tracking with automated alerting for unusual usage patterns or potential abuse
- Rate limiting violation tracking with user notification and potential security investigation triggers
- Professional tier subscription validation error tracking for billing and access control audit trails

**Security Requirements:** [Source: architecture/9-security-implementation.md]
- API key encryption and secure storage with rotation capability and deprecation management
- Row Level Security (RLS) policies preventing cross-tenant API data access
- API input validation and sanitization to prevent injection attacks via API parameters
- Professional tier authentication validation with secure session management and API scope enforcement

### Data Models
**Bangkok Dataset API Context:** [Source: architecture/1-bangkok-dataset-integration-pipeline.md, architecture/7-database-schema-bangkok-dataset-optimized.md]
```sql
-- Primary sensor data for API endpoints
CREATE TABLE sensor_readings (
    id BIGSERIAL PRIMARY KEY,
    timestamp TIMESTAMPTZ NOT NULL,
    sensor_id VARCHAR(50) NOT NULL,
    floor_number INTEGER NOT NULL,
    equipment_type VARCHAR(100),
    reading_value DECIMAL(10,4),
    unit VARCHAR(20),
    status VARCHAR(20) DEFAULT 'normal'
);

-- Performance optimized views for API responses
CREATE MATERIALIZED VIEW daily_aggregates AS
SELECT 
    DATE(timestamp) as date,
    sensor_id,
    floor_number,
    equipment_type,
    AVG(reading_value) as avg_value,
    MAX(reading_value) as max_value,
    MIN(reading_value) as min_value,
    COUNT(*) as reading_count
FROM sensor_readings
GROUP BY DATE(timestamp), sensor_id, floor_number, equipment_type;
```

**API Key Management Schema:** New tables for secure API access management
```sql
-- API key storage and management
CREATE TABLE api_keys (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id) NOT NULL,
    key_hash VARCHAR(64) NOT NULL UNIQUE, -- SHA-256 hash of the key
    key_prefix VARCHAR(8) NOT NULL, -- First 8 chars for user identification
    name VARCHAR(100) NOT NULL, -- User-defined key name
    scopes TEXT[] DEFAULT '{}', -- ['read:sensors', 'read:analytics', 'export:data']
    last_used_at TIMESTAMPTZ,
    expires_at TIMESTAMPTZ,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- API usage tracking for analytics and billing
CREATE TABLE api_usage_logs (
    id BIGSERIAL PRIMARY KEY,
    api_key_id UUID REFERENCES api_keys(id) NOT NULL,
    user_id UUID REFERENCES auth.users(id) NOT NULL,
    endpoint VARCHAR(255) NOT NULL,
    method VARCHAR(10) NOT NULL,
    status_code INTEGER NOT NULL,
    response_time_ms INTEGER,
    request_size_bytes INTEGER,
    response_size_bytes INTEGER,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Rate limiting tracking
CREATE TABLE rate_limit_usage (
    id BIGSERIAL PRIMARY KEY,
    api_key_id UUID REFERENCES api_keys(id) NOT NULL,
    time_window TIMESTAMPTZ NOT NULL, -- Hour window start
    request_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(api_key_id, time_window)
);

-- API usage analytics aggregations
CREATE TABLE daily_api_usage_summary (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) NOT NULL,
    date DATE NOT NULL,
    total_requests INTEGER DEFAULT 0,
    successful_requests INTEGER DEFAULT 0,
    error_requests INTEGER DEFAULT 0,
    avg_response_time_ms DECIMAL(8,2),
    total_data_transferred_bytes BIGINT DEFAULT 0,
    unique_endpoints INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(user_id, date)
);
```

**Subscription Integration:** [Source: architecture/7-database-schema-bangkok-dataset-optimized.md]
```sql
CREATE TABLE subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id),
    tier VARCHAR(20) NOT NULL DEFAULT 'free',
    stripe_subscription_id VARCHAR(100),
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ
);
```

**Dataset Context for API Responses:**
- 134 sensors across 7 floors with 18 months of historical data (2018-2019) for comprehensive API testing
- Equipment types include HVAC, lighting, power systems requiring different API response schemas
- Real-time sensor data ingestion pipeline integration for live API data endpoints
- Bangkok dataset size: 698MB total requiring pagination and efficient query optimization for API responses

### API Specifications
**Core API Endpoints:** [Source: architecture/8-api-architecture.md pattern]
```typescript
// Professional tier analytics API endpoints
GET /api/v1/sensors - List all accessible sensors with metadata
Query parameters: floor_number?, equipment_type?, status?, limit?, cursor?
Response: { sensors: ISensorMetadata[], pagination: IPaginationInfo }

GET /api/v1/sensors/{sensor_id}/readings - Time-series data for specific sensor
Query parameters: from?, to?, aggregation?, limit?, cursor?
Response: { readings: ISensorReading[], sensor: ISensorMetadata, pagination: IPaginationInfo }

GET /api/v1/analytics/summary - Dashboard analytics summary
Query parameters: time_range?, sensor_ids?, floor_numbers?, equipment_types?
Response: { summary: IAnalyticsSummary, time_range: ITimeRange, filters: IFilterInfo }

GET /api/v1/analytics/patterns - Failure pattern analysis
Query parameters: time_range?, pattern_type?, confidence_threshold?
Response: { patterns: IFailurePattern[], analysis_metadata: IAnalysisInfo }

GET /api/v1/analytics/trends - Trend analysis across sensors
Query parameters: metric?, time_range?, sensor_ids?, aggregation_level?
Response: { trends: ITrendData[], metadata: ITrendMetadata }

POST /api/v1/export/data - Create data export job
Body: { format: 'json' | 'csv' | 'excel', filters: IExportFilters, email_delivery?: boolean }
Response: { export_job_id: string, estimated_completion: string, download_url?: string }

GET /api/v1/export/{job_id} - Check export status and download
Response: { status: 'pending' | 'completed' | 'failed', download_url?: string, error?: string }

// Real-time data streaming
GET /api/v1/stream/sensors - WebSocket endpoint for real-time sensor data
WebSocket: Authenticated connection with sensor data updates and filtering

// API management endpoints
GET /api/v1/account/usage - Current API usage and quota information
Response: { current_usage: IUsageStats, quota_limits: IQuotaLimits, billing_period: IPeriodInfo }

POST /api/v1/account/api-keys - Create new API key
Body: { name: string, scopes: string[], expires_in_days?: number }
Response: { api_key: string, key_info: IApiKeyInfo } // key returned only once

GET /api/v1/account/api-keys - List user's API keys
Response: { api_keys: IApiKeyInfo[] } // sensitive key data excluded

PUT /api/v1/account/api-keys/{key_id} - Update API key
Body: { name?: string, scopes?: string[], is_active?: boolean }
Response: { api_key: IApiKeyInfo }

DELETE /api/v1/account/api-keys/{key_id} - Delete API key
Response: { success: boolean, message: string }
```

**Authentication and Authorization:** [Source: architecture/8-api-architecture.md]
```typescript
// API Key Authentication Header
Authorization: Bearer api_key_here

// Professional Tier Validation
- All API endpoints require valid Professional subscription
- API key validation checks subscription status and tier access
- Rate limiting enforced based on subscription tier
- Graceful degradation with upgrade prompts for expired subscriptions

// API Key Scopes
'read:sensors' - Read sensor metadata and current readings
'read:analytics' - Access analytics and trend data
'read:historical' - Access historical sensor data beyond 30 days
'export:data' - Create and download data exports
'stream:realtime' - Access real-time WebSocket data streams
```

**Rate Limiting Implementation:** [Source: architecture/8-api-architecture.md]
- Professional tier: 10,000 requests/hour with burst allowance to 12,000 for short periods
- Free tier: 100 requests/hour for basic sensor readings only (no analytics endpoints)
- Rate limit tracking with Redis for high-performance quota management
- Rate limit headers in all API responses: X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset
- Automatic rate limit notifications at 80% and 95% usage levels

### Component Specifications
**API Components Location:** `src/app/api/v1/` [Source: architecture/source-tree.md pattern]

**API Route Files:**
- `src/app/api/v1/sensors/route.ts` - Sensor metadata and listing
- `src/app/api/v1/sensors/[sensor_id]/readings/route.ts` - Time-series sensor data
- `src/app/api/v1/analytics/summary/route.ts` - Analytics summary dashboard data
- `src/app/api/v1/analytics/patterns/route.ts` - Failure pattern analysis
- `src/app/api/v1/analytics/trends/route.ts` - Trend analysis endpoints
- `src/app/api/v1/export/data/route.ts` - Data export job creation
- `src/app/api/v1/export/[job_id]/route.ts` - Export status and download
- `src/app/api/v1/stream/sensors/route.ts` - WebSocket real-time streaming
- `src/app/api/v1/account/usage/route.ts` - API usage and quota information
- `src/app/api/v1/account/api-keys/route.ts` - API key management CRUD
- `src/app/api/v1/account/api-keys/[key_id]/route.ts` - Individual API key operations

**API Utility Files:**
- `src/lib/api/authentication.ts` - API key validation and authentication middleware
- `src/lib/api/rateLimiting.ts` - Rate limiting implementation with Redis integration
- `src/lib/api/subscriptionValidator.ts` - Professional tier subscription validation
- `src/lib/api/responseFormatter.ts` - Standardized API response formatting
- `src/lib/api/errorHandling.ts` - Comprehensive API error handling and logging
- `src/lib/api/usageTracking.ts` - API usage analytics and logging
- `src/lib/api/documentation.ts` - OpenAPI specification and Swagger UI integration
- `src/lib/api/pagination.ts` - Cursor-based pagination for large datasets
- `src/lib/api/dataValidation.ts` - Zod schema validation for API inputs and outputs

**API Management Components:**
- `src/components/features/api/ApiKeyManagement.tsx` - API key creation and management interface
- `src/components/features/api/ApiUsageDashboard.tsx` - API usage analytics and quota display
- `src/components/features/api/ApiDocumentation.tsx` - Embedded API documentation viewer
- `src/components/features/api/RateLimitDisplay.tsx` - Current rate limit status display
- `src/components/features/api/ApiKeyCreationModal.tsx` - API key creation interface with scoping
- `src/components/features/api/UsageAnalyticsChart.tsx` - API usage trends and analytics visualization

**SDK and Example Files:**
- `sdk/typescript/` - TypeScript/JavaScript SDK implementation
- `sdk/python/` - Python SDK with data science utilities
- `examples/curl/` - cURL examples for all API endpoints
- `examples/integrations/` - Integration examples for facility management systems
- `examples/typescript/` - TypeScript integration examples
- `examples/python/` - Python integration examples with pandas

### File Locations
**API Route Structure:** [Source: architecture/source-tree.md pattern]
```
src/app/api/v1/
├── sensors/
│   ├── route.ts                    # GET /api/v1/sensors
│   └── [sensor_id]/
│       └── readings/
│           └── route.ts            # GET /api/v1/sensors/{id}/readings
├── analytics/
│   ├── summary/
│   │   └── route.ts               # GET /api/v1/analytics/summary
│   ├── patterns/
│   │   └── route.ts               # GET /api/v1/analytics/patterns
│   └── trends/
│       └── route.ts               # GET /api/v1/analytics/trends
├── export/
│   ├── data/
│   │   └── route.ts               # POST /api/v1/export/data
│   └── [job_id]/
│       └── route.ts               # GET /api/v1/export/{job_id}
├── stream/
│   └── sensors/
│       └── route.ts               # WebSocket /api/v1/stream/sensors
└── account/
    ├── usage/
    │   └── route.ts               # GET /api/v1/account/usage
    └── api-keys/
        ├── route.ts               # GET/POST /api/v1/account/api-keys
        └── [key_id]/
            └── route.ts           # PUT/DELETE /api/v1/account/api-keys/{id}
```

**API Utility Files:**
- `src/lib/api/authentication.ts` - API key authentication middleware
- `src/lib/api/rateLimiting.ts` - Rate limiting with Redis backend
- `src/lib/api/subscriptionValidator.ts` - Professional tier validation
- `src/lib/api/responseFormatter.ts` - Standardized JSON response formatting
- `src/lib/api/errorHandling.ts` - Comprehensive error handling
- `src/lib/api/usageTracking.ts` - Usage analytics and logging
- `src/lib/api/pagination.ts` - Cursor-based pagination utilities
- `src/lib/api/dataValidation.ts` - Zod validation schemas

**Type Definitions:**
- `src/types/api.ts` - API request/response type definitions [Source: architecture/source-tree.md pattern]
- `src/types/apiKeys.ts` - API key management type definitions
- `src/types/usage.ts` - Usage analytics and quota type definitions
- `src/types/sensors.ts` - Sensor data API response types
- `src/types/analytics.ts` - Analytics API response types

**Hook Files:**
- `src/hooks/useApiKeys.ts` - API key management hooks
- `src/hooks/useApiUsage.ts` - API usage analytics hooks
- `src/hooks/useApiDocumentation.ts` - API documentation integration hooks

### Testing Standards
**Test Coverage:** 85% minimum, 100% for API authentication and rate limiting business logic [Source: architecture/5-testing-framework-setup-installation.md]

**Critical Test Scenarios:**
- API authentication with valid and invalid API keys including edge cases
- Rate limiting enforcement with Professional and Free tier quotas including burst scenarios
- Bangkok dataset API response performance with large result sets and pagination
- Professional tier subscription validation and graceful degradation for expired subscriptions
- API usage tracking accuracy and analytics calculation verification
- WebSocket real-time API connection stability and data streaming accuracy
- API error handling and response consistency across all endpoints

**Required Test Types:** [Source: architecture/5-testing-framework-setup-installation.md]
- Unit Tests: API utility functions, authentication validators, rate limiting logic
- Integration Tests: API endpoints with database operations and subscription validation
- E2E Tests: Complete API workflow from key generation through data retrieval
- Performance Tests: API load testing with Bangkok dataset scale and concurrent users
- Security Tests: API authentication bypass attempts, injection attacks, rate limit abuse

**Test Files Location:** [Source: architecture/source-tree.md pattern]
- `__tests__/api/v1/sensors.test.ts`
- `__tests__/api/v1/analytics.test.ts`
- `__tests__/api/v1/account/api-keys.test.ts`
- `__tests__/lib/api/authentication.test.ts`
- `__tests__/lib/api/rateLimiting.test.ts`
- `__tests__/components/api/ApiKeyManagement.test.tsx`
- `__tests__/integration/apiWorkflow.test.ts`
- `__tests__/e2e/apiIntegration.spec.ts`

### Technical Constraints
**Performance Requirements:** [Source: architecture/tech-stack.md, architecture/10-monitoring-observability.md]
- API response times: <500ms average, <1s 95th percentile for all endpoints
- Bangkok dataset query optimization: <100ms for sensor readings, <1s for complex analytics
- API key validation latency: <50ms with Redis caching
- Rate limiting check performance: <10ms per request with efficient Redis operations
- WebSocket connection establishment: <200ms with stable low-latency data streaming

**Bangkok Dataset Constraints:** [Source: architecture/1-bangkok-dataset-integration-pipeline.md]
- 134 sensors requiring efficient API query optimization without database overload
- 18 months historical data requiring pagination and date range filtering
- Real-time data ingestion pipeline integration for live API endpoints
- Equipment type diversity requiring flexible API response schemas and filtering

**Technology Constraints:** [Source: architecture/2-ultra-lean-technology-stack.md]
- Next.js 14+ App Router for API route implementation and middleware
- Supabase PostgreSQL with Row Level Security for multi-tenant API data access
- Redis integration for high-performance rate limiting and API key caching
- TypeScript strict mode for comprehensive API type safety and validation

**Service Integration Constraints:** [Source: architecture/8-api-architecture.md]
- Supabase rate limits: 100 concurrent connections with API request optimization
- Redis caching for rate limiting: Efficient quota tracking without service overload
- Professional tier subscription validation: Real-time Stripe subscription status checking
- Email service integration: API usage notifications and quota alerts via existing email service

## Project Structure Notes

**Alignment Verified:** All API file paths and component locations align with the defined project structure in `source-tree.md`. The API structure follows Next.js App Router patterns with versioned API routes under `/api/v1/` for future-proof API evolution.

**Key Structural Additions:**
- New versioned API structure under `src/app/api/v1/` following REST conventions with nested resource endpoints
- API utility libraries organized in `src/lib/api/` directory following established patterns from existing utilities
- API management components in `src/components/features/api/` maintaining consistency with existing feature organization
- SDK and example code in dedicated `sdk/` and `examples/` directories at project root level
- API-specific type definitions in `src/types/` directory integrating with existing type organization

**Database Schema Integration:**
- New API key management tables integrate with existing `auth.users` table for user relationships
- API usage tracking tables designed for efficient analytics queries and reporting
- Rate limiting tables optimized for high-frequency read/write operations with Redis integration
- Subscription validation through existing `subscriptions` table for Professional tier access control

**API Authentication Architecture:**
- API key authentication system integrates with existing NextAuth.js session management
- Professional tier validation middleware extends existing subscription checking patterns
- Rate limiting system designed for high-performance with Redis backend integration
- API scoping and permission system designed for future expansion and granular access control

**Performance Optimization Integration:**
- API endpoints leverage existing materialized views and query optimization from dashboard implementation
- Bangkok dataset query patterns reuse existing performance optimizations from analytics features
- Pagination and filtering systems build upon existing data processing patterns
- Real-time API endpoints integrate with existing WebSocket infrastructure from dashboard features

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-09-11 | 1.0 | Initial story creation with comprehensive API technical context | BMAD Scrum Master |

## Dev Agent Record

*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be populated during development*

### Debug Log References  
*To be populated during development*

### Completion Notes List
*To be populated during development*

### File List
*To be populated during development*

## QA Results

*Results from QA Agent review will be populated here after implementation*