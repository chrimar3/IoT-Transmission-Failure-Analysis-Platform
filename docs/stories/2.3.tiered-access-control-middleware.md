# Story 2.3: Tiered Access Control Middleware

## Status
Draft

## Story
**As the** system,
**I want** to enforce access controls based on subscription tiers,
**so that** users only access features appropriate to their subscription level while protecting business value and ensuring Professional subscribers receive full access to advanced features.

## Acceptance Criteria
1. Free tier users limited to view-only dashboard access with 30-day historical data
2. Professional tier users granted full analytics, data export capabilities, and alert configurations
3. API endpoints enforce tier limitations with proper HTTP status codes and error messages
4. Real-time subscription status checks integrated with NextAuth.js sessions
5. Clear, user-friendly error messages for insufficient permissions with upgrade prompts
6. Graceful degradation for expired subscriptions with grace period handling
7. Middleware performance <100ms for subscription status validation
8. Integration with Stripe subscription status from Story 2.2
9. React component tier awareness with feature flagging and disabled state handling
10. Comprehensive audit logging for access control decisions and policy violations

## Priority & Effort
**Priority**: P0 (Blocking - Critical Integration Story)
**Effort**: 3 points
**Epic**: Epic 2 - User Authentication & Subscription Management

## Tasks / Subtasks
- [ ] Create tier-based middleware for API route protection (AC: 3,4,7,10)
  - [ ] Implement `/src/middleware.ts` with NextAuth.js and subscription integration
  - [ ] Create subscription status checking utility in `/src/lib/subscription-access.ts`
  - [ ] Add tier validation middleware for API routes with performance optimization
  - [ ] Implement caching layer for subscription status (24-hour TTL with real-time invalidation)
  - [ ] Add comprehensive audit logging for access control decisions
  - [ ] Create rate limiting integration based on subscription tier (100/hour free, 10k/hour professional)
- [ ] Implement React component tier awareness system (AC: 1,2,5,9)
  - [ ] Create `useSubscriptionTier` hook in `/src/hooks/useSubscriptionTier.ts`
  - [ ] Build `TierGate` component for conditional feature rendering
  - [ ] Add `UpgradePrompt` component for insufficient permissions
  - [ ] Create feature flagging utilities for tier-based functionality
  - [ ] Implement disabled state handling for premium features on free accounts
  - [ ] Add tier-aware navigation and menu system
- [ ] Add subscription status validation and caching (AC: 4,6,8)
  - [ ] Create subscription status API endpoint `/src/app/api/subscription/status/route.ts`
  - [ ] Implement real-time subscription status updates via webhooks from Story 2.2
  - [ ] Add grace period handling for expired subscriptions (7-day grace period)
  - [ ] Create subscription status cache invalidation on payment events
  - [ ] Add fallback mechanisms for Stripe API outages
  - [ ] Implement subscription tier change notifications
- [ ] Create permission checking utilities and error handling (AC: 3,5,10)
  - [ ] Build permission validation functions in `/src/lib/permissions.ts`
  - [ ] Create standardized error responses for insufficient permissions (HTTP 403)
  - [ ] Add user-friendly error messages with specific upgrade paths
  - [ ] Implement feature-specific permission checks (export, alerts, full analytics)
  - [ ] Add comprehensive error logging and monitoring integration
  - [ ] Create permission audit trail for compliance and debugging
- [ ] Implement graceful access control UX and upgrade flow (AC: 5,6,9)
  - [ ] Design and build upgrade prompt modals and banners
  - [ ] Create graceful degradation UI for expired subscriptions
  - [ ] Add tier-aware dashboard sections with clear upgrade messaging
  - [ ] Implement feature preview for premium capabilities
  - [ ] Add usage limit indicators and progress bars for free tier
  - [ ] Create seamless upgrade flow integration with Story 2.2 Stripe checkout
- [ ] Add comprehensive testing suite for access control (AC: All)
  - [ ] Unit tests for subscription tier validation and permission checking
  - [ ] Integration tests for middleware with various subscription states
  - [ ] Component tests for tier-aware UI with different subscription levels
  - [ ] End-to-end tests for complete access control flows
  - [ ] Performance tests for middleware response times <100ms
  - [ ] Security tests for privilege escalation and bypass attempts

## Dev Notes

### Previous Story Insights
Building the access control layer that integrates with:
- **Story 2.1**: NextAuth.js authentication provides secure user sessions and identity management
- **Story 2.2**: Stripe subscription integration provides subscription status and webhook updates
- **Story 1.4**: Core API endpoints require protection based on subscription tier
- **Story 1.2**: Database schema includes subscriptions table for tier tracking

This story creates the critical business protection layer that enforces the subscription model, ensuring revenue protection by limiting free users while providing full access to Professional subscribers.

### Data Models
[Source: architecture/7-database-schema-bangkok-dataset-optimized.md]

**Subscription Access Control**: Integration with existing subscriptions table
```sql
-- Extended subscription fields for access control
ALTER TABLE subscriptions ADD COLUMN IF NOT EXISTS:
  access_level VARCHAR(20) DEFAULT 'free', -- 'free' | 'professional'
  feature_flags JSONB DEFAULT '{}',        -- Feature-specific permissions
  rate_limit_tier INTEGER DEFAULT 100,     -- Requests per hour
  grace_period_end TIMESTAMPTZ NULL,       -- Grace period for expired subscriptions
  last_access_check TIMESTAMPTZ DEFAULT NOW() -- Performance optimization
```

**Access Control Audit Log**: New table for compliance and debugging
```sql
CREATE TABLE access_control_audit (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id),
    resource VARCHAR(100) NOT NULL,        -- API endpoint or feature accessed
    subscription_tier VARCHAR(20) NOT NULL, -- User's tier at time of access
    access_granted BOOLEAN NOT NULL,        -- Whether access was granted
    reason VARCHAR(500),                    -- Reason for denial if applicable
    ip_address INET,                       -- Request IP for security tracking
    user_agent TEXT,                       -- Request user agent
    created_at TIMESTAMPTZ DEFAULT NOW()
);
```

**Permission Matrix Definition**:
- **Free Tier Permissions**: 
  - Dashboard view-only access (last 30 days of data)
  - Basic analytics charts (summary level only)
  - Limited API access (100 requests/hour)
  - No data export capabilities
  - No alert configurations
- **Professional Tier Permissions**: 
  - Full dashboard access (all historical data)
  - Advanced analytics with custom date ranges
  - Unlimited API access (10,000 requests/hour)
  - CSV/PDF export capabilities
  - Email alert configurations
  - API access to all endpoints

### API Specifications
[Source: architecture/8-api-architecture.md]

**Access Control API Endpoints**:
- GET /api/subscription/status - Current tier and permissions with caching
- GET /api/subscription/permissions - Feature-specific permission matrix
- POST /api/subscription/check-access - Real-time access validation for features
- GET /api/audit/access-log - Access control audit trail (admin only)

**Rate Limiting Integration** [Source: architecture/8-api-architecture.md]:
- **Free tier**: 100 requests/hour with clear messaging when limits approached
- **Professional tier**: 10,000 requests/hour with burst allowance
- **Rate limit headers**: X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset
- **Tier-based rate limiting**: Immediate enforcement upon subscription changes

**Protected Endpoint Pattern**:
```typescript
// Example: /api/export/csv requires Professional tier
export async function GET(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session) return unauthorizedResponse();
  
  const { hasAccess, reason } = await checkSubscriptionAccess(
    session.user.id,
    'data_export'
  );
  
  if (!hasAccess) {
    return NextResponse.json({
      error: 'Insufficient permissions',
      message: 'Data export requires Professional tier subscription',
      upgradeUrl: '/subscription/upgrade',
      reason
    }, { status: 403 });
  }
  
  // Continue with export functionality
}
```

**Graceful Degradation During Service Outages**:
- Local subscription status caching (24-hour TTL)
- Fallback to last known subscription state during Stripe API outages
- Grace period handling for payment processing delays
- Limited functionality maintenance during authentication service issues

### Component Specifications
[Source: architecture/coding-standards.md]

**Subscription Access Control Utilities**:
```typescript
// src/lib/subscription-access.ts
export interface ISubscriptionAccess {
  tier: 'free' | 'professional';
  hasAccess: boolean;
  permissions: IPermissionMatrix;
  rateLimit: IRateLimit;
  graceStatus?: IGraceStatus;
}

export const checkSubscriptionAccess = async (
  userId: string,
  feature: string
): Promise<ISubscriptionAccess> => {
  // Implementation with caching and real-time validation
};

export const getPermissionMatrix = (tier: string): IPermissionMatrix => {
  return {
    canExportData: tier === 'professional',
    canConfigureAlerts: tier === 'professional',
    canAccessFullHistory: tier === 'professional',
    maxApiRequestsPerHour: tier === 'professional' ? 10000 : 100,
    canAccessAdvancedAnalytics: tier === 'professional'
  };
};
```

**React Subscription Tier Hook**:
```typescript
// src/hooks/useSubscriptionTier.ts
export const useSubscriptionTier = () => {
  const [tierData, setTierData] = useState<ISubscriptionAccess | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const { data: session } = useSession();

  useEffect(() => {
    if (session?.user?.id) {
      fetchSubscriptionTier(session.user.id)
        .then(setTierData)
        .finally(() => setIsLoading(false));
    }
  }, [session?.user?.id]);

  return {
    tier: tierData?.tier || 'free',
    permissions: tierData?.permissions || getPermissionMatrix('free'),
    hasAccess: (feature: string) => tierData?.permissions?.[feature] || false,
    isLoading,
    upgradeRequired: tierData?.tier === 'free'
  };
};
```

**TierGate Component for Feature Protection**:
```typescript
// src/components/features/subscription/TierGate.tsx
interface ITierGateProps {
  requiredTier: 'professional';
  feature: string;
  children: React.ReactNode;
  fallback?: React.ReactNode;
  showUpgradePrompt?: boolean;
}

export const TierGate: React.FC<ITierGateProps> = ({
  requiredTier,
  feature,
  children,
  fallback,
  showUpgradePrompt = true
}) => {
  const { hasAccess, isLoading } = useSubscriptionTier();
  
  if (isLoading) return <LoadingSpinner />;
  
  if (!hasAccess(feature)) {
    return fallback || (
      showUpgradePrompt ? <UpgradePrompt feature={feature} /> : null
    );
  }
  
  return <>{children}</>;
};
```

**Middleware Implementation**:
```typescript
// src/middleware.ts
import { withAuth } from "next-auth/middleware";
import { checkSubscriptionAccess } from "@/lib/subscription-access";

export default withAuth(
  async function middleware(req) {
    const token = req.nextauth.token;
    
    // Check if route requires specific subscription tier
    if (req.nextUrl.pathname.startsWith('/api/export/')) {
      const { hasAccess } = await checkSubscriptionAccess(
        token.sub,
        'data_export'
      );
      
      if (!hasAccess) {
        return NextResponse.json({
          error: 'Insufficient permissions',
          upgradeUrl: '/subscription/upgrade'
        }, { status: 403 });
      }
    }
  },
  {
    callbacks: {
      authorized: ({ token }) => !!token
    },
  }
);

export const config = {
  matcher: ["/dashboard/:path*", "/api/analytics/:path*", "/api/export/:path*"]
};
```

### File Locations
[Source: architecture/source-tree.md]

**Core Access Control Infrastructure**:
- `/src/lib/subscription-access.ts` - Subscription tier validation and permission checking
- `/src/lib/permissions.ts` - Permission matrix definitions and validation utilities
- `/src/middleware.ts` - NextAuth.js middleware with tier-based route protection
- `/src/types/subscription.ts` - TypeScript types for subscription and permissions

**API Endpoints for Access Control**:
- `/src/app/api/subscription/status/route.ts` - Current subscription status with permissions
- `/src/app/api/subscription/permissions/route.ts` - Feature permission matrix endpoint
- `/src/app/api/subscription/check-access/route.ts` - Real-time access validation
- `/src/app/api/audit/access-log/route.ts` - Access control audit trail

**React Components for Tier Management**:
- `/src/components/features/subscription/TierGate.tsx` - Feature gating component
- `/src/components/features/subscription/UpgradePrompt.tsx` - Upgrade messaging component
- `/src/components/features/subscription/PermissionDenied.tsx` - Access denied UI
- `/src/components/features/subscription/TierIndicator.tsx` - Current tier display

**Hooks and Utilities**:
- `/src/hooks/useSubscriptionTier.ts` - Subscription tier state management
- `/src/hooks/useFeatureAccess.ts` - Feature-specific access checking
- `/src/components/ui/LoadingSpinner.tsx` - Loading state for permission checks

**Tests**:
- `/__tests__/lib/subscription-access.test.ts` - Access control utility tests
- `/__tests__/middleware/tier-protection.test.ts` - Middleware integration tests
- `/__tests__/components/subscription/` - Tier-aware component tests
- `/__tests__/api/subscription/` - Access control API endpoint tests

### Technical Constraints
[Source: architecture/tech-stack.md]

**Performance Requirements**:
- Middleware response time: <100ms for subscription validation (95th percentile)
- Subscription status API: <200ms response time with caching
- Permission matrix lookup: <50ms for cached results
- Database queries: Optimized with proper indexing on subscription fields

**Caching Strategy**:
- Subscription status: 24-hour TTL with real-time invalidation on webhook events
- Permission matrix: Application-level caching for performance
- User session integration: NextAuth.js JWT token with subscription metadata
- Redis integration for distributed caching across serverless functions

**Security Requirements**:
- No client-side permission enforcement (server-side only)
- Audit logging for all access control decisions
- Protection against privilege escalation attacks
- Secure session integration with NextAuth.js
- Rate limiting enforcement based on subscription tier

**Integration Requirements**:
- **NextAuth.js**: Session management and user identification
- **Stripe Webhooks**: Real-time subscription status updates from Story 2.2
- **Supabase RLS**: Database-level access control for data queries
- **API Endpoints**: Protection of all business-critical endpoints from Story 1.4

### Testing Requirements
[Source: architecture/5-testing-framework-setup-installation.md]

**Test Coverage Requirements**:
- 100% coverage for access control utilities and permission checking
- 100% coverage for middleware functionality with various subscription states
- 85% minimum coverage for tier-aware React components
- Integration testing with mock Stripe subscription states

**Testing Frameworks and Patterns**:
- Jest for unit testing with subscription mocks
- React Testing Library for component testing with different tiers
- Supertest for API endpoint access control testing
- Mock service worker (MSW) for Stripe API mocking

**Specific Testing Requirements**:
- Permission matrix validation for all subscription tiers
- Middleware performance testing with <100ms requirement
- Component behavior testing for free vs professional tier users
- Error handling testing for expired subscriptions and API failures
- Security testing for privilege escalation attempts
- End-to-end testing for complete access control flows

**Test Data and Scenarios**:
- Mock users with different subscription tiers (free, professional, expired)
- API endpoint protection testing with various permission levels
- Grace period handling testing for expired subscriptions
- Subscription tier change testing with immediate access updates
- Error scenario testing (Stripe API outages, database failures)

### Production Readiness

**Monitoring and Alerting**:
- Access control audit log monitoring with anomaly detection
- Permission denial rate tracking with threshold alerts
- Subscription status cache hit rate monitoring
- API endpoint protection effectiveness tracking

**Error Handling and Recovery**:
- Graceful degradation during subscription service outages
- Clear user messaging for permission denials with upgrade paths
- Fallback to last known subscription status during API failures
- Comprehensive error logging for debugging and compliance

**Performance Optimization**:
- Subscription status caching with intelligent invalidation
- Permission matrix pre-computation for common scenarios
- Database query optimization for subscription lookups
- CDN integration for tier-based static asset serving

**Business Logic Validation**:
- Subscription tier enforcement across all application features
- Revenue protection through proper access control implementation
- Free tier limitations clearly communicated to users
- Professional tier value proposition highlighted in upgrade prompts

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-11 | 1.0 | Initial story creation with basic requirements | User |
| 2025-01-11 | 2.0 | Comprehensive enhancement with full technical context and implementation details | BMAD Agent |

## Dev Agent Record

*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*Results from QA Agent review of the completed story implementation*