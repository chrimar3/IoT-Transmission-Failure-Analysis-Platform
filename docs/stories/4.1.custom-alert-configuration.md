# Story 4.1: Custom Alert Configuration

## Status
Draft

## Story
**As a** facility manager,  
**I want** to configure custom alerts  
**so that** I'm immediately notified of critical issues that require my attention

## Acceptance Criteria

### AC1: Sensor/Equipment Alert Configuration
- Configure alerts for specific sensors or equipment types from Bangkok dataset (134 sensors, 7 floors)
- Select individual sensors or groups by floor, equipment type, or custom sensor collections
- Alert configuration UI shows sensor metadata (location, equipment type, current status)
- Support bulk alert configuration for multiple sensors simultaneously
- Validation ensures selected sensors are active and accessible to user's subscription

### AC2: Custom Threshold Configuration
- Set custom thresholds for different alert types (value-based, deviation-based, trend-based)
- Configure threshold parameters: minimum/maximum values, percentage change thresholds, time-window specifications
- Support multiple threshold conditions per sensor (warning, critical levels)
- Threshold validation against historical sensor data ranges to prevent false positives
- Template-based threshold presets for common equipment types

### AC3: Multi-Channel Notification System
- Email notifications with customizable templates and recipient lists
- In-app notifications with real-time browser notifications and dashboard alerts
- Professional tier exclusive feature with subscription validation
- Notification preferences per alert type and severity level
- Email delivery tracking with bounce handling and delivery confirmation

### AC4: Alert Severity Levels
- Three severity levels: Critical, Warning, Info with distinct notification behaviors
- Critical: Immediate email + in-app + escalation after 15 minutes if unacknowledged
- Warning: Email + in-app notification with 1-hour digest option
- Info: In-app only with daily digest email option
- Configurable escalation rules and notification frequency per severity

### AC5: Alert Acknowledgment and Resolution Tracking
- Alert acknowledgment system with timestamp and user tracking
- Resolution workflow with status updates (Acknowledged, In Progress, Resolved)
- Alert escalation for unacknowledged critical alerts (15-minute automatic escalation)
- Resolution notes and action tracking for audit and learning purposes
- Alert state persistence across user sessions

### AC6: Professional Tier Access Control
- Custom alert configuration exclusively for Professional subscribers ($29/month)
- Free tier users see view-only basic system alerts
- Subscription validation on all alert management operations
- Graceful degradation when subscription expires (alerts disabled, notification cleanup)
- Professional tier feature promotion in Free tier user interface

## Priority & Effort
**Priority**: P0 (Retention Critical)  
**Effort**: 4 points  
**Epic**: 4 (MVP Completion)

## Tasks / Subtasks

### Task 1: Alert Configuration Database Schema and Data Models (AC: 1, 2, 4)
**Subtasks:**
1.1. Create alert configuration database tables with proper relationships to sensor_readings and subscriptions
1.2. Implement alert rules engine data structures supporting multiple threshold types
1.3. Create alert instance tracking tables for acknowledgment and resolution workflow
1.4. Add database indexes for efficient alert evaluation and notification retrieval
1.5. Implement Row Level Security (RLS) policies for multi-tenant alert isolation
1.6. Create database migration scripts with rollback procedures for production deployment
1.7. Add data validation constraints and foreign key relationships for data integrity

### Task 2: Real-time Alert Evaluation Engine (AC: 1, 2, 4)
**Subtasks:**
2.1. Implement threshold evaluation logic for value-based, deviation-based, and trend-based alerts
2.2. Create background job system for continuous sensor data monitoring against alert rules
2.3. Add alert state management with severity escalation and acknowledgment tracking
2.4. Implement efficient alert evaluation using materialized views and optimized queries
2.5. Create alert duplicate prevention and grouping logic for related sensor failures
2.6. Add performance optimization for 134-sensor Bangkok dataset scale monitoring
2.7. Implement comprehensive error handling and recovery for alert evaluation failures

### Task 3: Email Notification Service Integration (AC: 3, 4)
**Subtasks:**
3.1. Integrate email service with customizable alert notification templates
3.2. Implement email delivery queue with retry logic and failure handling
3.3. Create email template system supporting alert context and branding customization
3.4. Add recipient management with professional tier subscription validation
3.5. Implement email delivery tracking with bounce handling and confirmation receipts
3.6. Create email rate limiting and quota management to prevent spam classification
3.7. Add comprehensive email service testing with mock delivery validation

### Task 4: In-App Real-time Notification System (AC: 3, 4, 5)
**Subtasks:**
4.1. Create real-time WebSocket connection for instant alert delivery to browser
4.2. Implement in-app notification UI components with severity-based styling and behavior
4.3. Add browser notification API integration with user permission handling
4.4. Create notification center with alert history, acknowledgment, and resolution interface
4.5. Implement real-time alert state synchronization across multiple user sessions
4.6. Add notification sound alerts with user preference controls for critical alerts
4.7. Create mobile-responsive notification interface for tablet facility management use

### Task 5: Alert Configuration User Interface (AC: 1, 2, 4, 6)
**Subtasks:**
5.1. Create alert configuration dashboard with sensor selection and threshold setting interface
5.2. Implement sensor browser with floor-based organization and equipment type filtering
5.3. Add threshold configuration forms with real-time validation against historical data
5.4. Create alert template system with presets for common equipment types and failure patterns
5.5. Implement bulk alert configuration tools for efficient multi-sensor setup
5.6. Add alert configuration preview and testing capabilities before activation
5.7. Create professional tier subscription gate with upgrade promotion for free users

### Task 6: Alert Management and Resolution Workflow (AC: 5)
**Subtasks:**
6.1. Create alert dashboard showing active, acknowledged, and resolved alerts with filtering
6.2. Implement alert acknowledgment interface with user tracking and timestamp recording
6.3. Add alert resolution workflow with status updates and resolution notes
6.4. Create escalation management for critical unacknowledged alerts with automatic escalation
6.5. Implement alert history and analytics for pattern identification and system optimization
6.6. Add alert resolution reporting for audit trails and performance measurement
6.7. Create alert workflow mobile optimization for on-the-go facility management

### Task 7: Subscription Integration and Access Control (AC: 6)
**Subtasks:**
7.1. Implement professional tier subscription validation for all alert configuration endpoints
7.2. Create subscription status checking middleware for alert system access control
7.3. Add graceful degradation handling for expired subscriptions with user notification
7.4. Implement alert feature restrictions and limits based on subscription tier
7.5. Create subscription upgrade prompts and professional tier feature marketing in free tier UI
7.6. Add subscription billing integration for alert usage tracking and tier validation
7.7. Create comprehensive subscription integration testing with mock payment scenarios

### Task 8: Alert System Testing, Performance, and Monitoring (AC: 1-6)
**Subtasks:**
8.1. Create comprehensive unit tests for alert evaluation engine and notification system
8.2. Implement integration tests for email delivery, real-time notifications, and database operations
8.3. Add performance testing for Bangkok dataset scale (134 sensors) with concurrent alert evaluation
8.4. Create E2E tests covering complete alert lifecycle from configuration to resolution
8.5. Implement alert system performance monitoring with response time and reliability metrics
8.6. Add error tracking and logging for alert failures with automated recovery procedures
8.7. Create alert system load testing with high-frequency sensor data and multiple concurrent users

## Dev Notes

### Previous Story Insights
**From Story 3.4 Implementation (Data Export):** Email delivery service integration patterns and Professional tier subscription validation middleware provide foundation for alert email notifications. The email template system and delivery confirmation tracking can be adapted for alert notifications. Usage tracking patterns from export functionality will inform alert configuration limits and monitoring. [Source: Previous story context from 3.4.story.md]

**From Story 3.1-3.3 Dashboard Implementation:** Real-time data visualization patterns and WebSocket connections from dashboard components provide foundation for real-time alert notifications. Sensor data filtering and selection interfaces can be reused for alert configuration. Chart interaction patterns inform alert threshold visualization and configuration UI. [Source: Previous story context from dashboard stories]

### Production Readiness Requirements
**API Failure Handling:** [Source: architecture/8-api-architecture.md]
- Alert evaluation system must implement exponential backoff retry logic for database connection failures
- Email notification failures require dead letter queue with manual reconciliation dashboard  
- WebSocket connection failures need automatic reconnection with alert state synchronization
- Service degradation during Supabase outages requires local alert state caching with 24-hour TTL

**Service Rate Limit Monitoring:** [Source: architecture/8-api-architecture.md]
- Supabase connection monitoring: 100 concurrent connections with alert evaluation throttling at 80% capacity
- Email service rate limits: 3K emails/month free tier, 100 emails/day with automated scaling alerts
- Real-time notification rate limiting to prevent client flooding during mass alert events
- Alert evaluation frequency optimization to stay within database query quotas

**Performance Benchmarks:** [Source: architecture/10-monitoring-observability.md]
- Alert evaluation latency: <30 seconds from sensor data ingestion to notification delivery
- Real-time notification delivery: <5 seconds from alert trigger to browser notification
- Email notification delivery: <2 minutes from alert trigger to email delivery confirmation
- System uptime: 99.9% availability with <5 minute MTTR for alert system outages

**Error Logging and Alerting:** [Source: architecture/10-monitoring-observability.md]  
- Comprehensive error tracking with Sentry integration for alert evaluation failures
- Alert system health monitoring with automated escalation for service degradation
- Email delivery failure tracking with bounce rate monitoring and sender reputation management
- Database performance monitoring for alert evaluation query optimization

**Security Requirements:** [Source: architecture/9-security-implementation.md]
- Row Level Security (RLS) policies preventing cross-tenant alert access
- Alert notification content validation to prevent injection attacks via sensor data
- Email recipient validation and sanitization to prevent spam and abuse
- Professional tier authentication validation with secure session management

### Data Models
**Primary Sensor Data Source:** `sensor_readings` table [Source: architecture/7-database-schema-bangkok-dataset-optimized.md]
```sql
CREATE TABLE sensor_readings (
    id BIGSERIAL PRIMARY KEY,
    timestamp TIMESTAMPTZ NOT NULL,
    sensor_id VARCHAR(50) NOT NULL,
    floor_number INTEGER NOT NULL,
    equipment_type VARCHAR(100),
    reading_value DECIMAL(10,4),
    unit VARCHAR(20),
    status VARCHAR(20) DEFAULT 'normal'
);
```

**Performance Optimization Data Source:** `daily_aggregates` materialized view [Source: architecture/7-database-schema-bangkok-dataset-optimized.md]
```sql
CREATE MATERIALIZED VIEW daily_aggregates AS
SELECT 
    DATE(timestamp) as date,
    sensor_id,
    floor_number,
    equipment_type,
    AVG(reading_value) as avg_value,
    MAX(reading_value) as max_value,
    MIN(reading_value) as min_value,
    COUNT(*) as reading_count
FROM sensor_readings
GROUP BY DATE(timestamp), sensor_id, floor_number, equipment_type;
```

**Alert System Schema:** New tables required for comprehensive alert management
```sql
-- Alert rule definitions
CREATE TABLE alert_rules (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) NOT NULL,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    sensor_id VARCHAR(50) NOT NULL, -- matches sensor_readings.sensor_id
    equipment_type VARCHAR(100), -- optional filter
    floor_number INTEGER, -- optional filter
    threshold_type VARCHAR(50) NOT NULL, -- 'value', 'deviation', 'trend'
    threshold_config JSONB NOT NULL, -- {min_value, max_value, deviation_percent, time_window}
    severity VARCHAR(20) NOT NULL, -- 'critical', 'warning', 'info'
    notification_channels TEXT[] DEFAULT '{}', -- ['email', 'in_app', 'browser']
    email_recipients TEXT[] DEFAULT '{}',
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Active alert instances
CREATE TABLE alert_instances (
    id BIGSERIAL PRIMARY KEY,
    alert_rule_id BIGINT REFERENCES alert_rules(id) NOT NULL,
    sensor_id VARCHAR(50) NOT NULL,
    triggered_at TIMESTAMPTZ NOT NULL,
    trigger_value DECIMAL(10,4) NOT NULL,
    severity VARCHAR(20) NOT NULL,
    status VARCHAR(20) DEFAULT 'active', -- 'active', 'acknowledged', 'resolved'
    acknowledged_at TIMESTAMPTZ,
    acknowledged_by UUID REFERENCES auth.users(id),
    resolved_at TIMESTAMPTZ,
    resolved_by UUID REFERENCES auth.users(id),
    resolution_notes TEXT,
    notification_sent BOOLEAN DEFAULT FALSE,
    email_delivered BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Alert notification tracking
CREATE TABLE alert_notifications (
    id BIGSERIAL PRIMARY KEY,
    alert_instance_id BIGINT REFERENCES alert_instances(id) NOT NULL,
    notification_type VARCHAR(20) NOT NULL, -- 'email', 'in_app', 'browser'
    recipient_email VARCHAR(255), -- for email notifications
    sent_at TIMESTAMPTZ NOT NULL,
    delivery_status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'delivered', 'bounced', 'failed'
    delivery_confirmed_at TIMESTAMPTZ,
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Alert templates for common configurations
CREATE TABLE alert_templates (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    equipment_type VARCHAR(100) NOT NULL,
    default_thresholds JSONB NOT NULL,
    recommended_severity VARCHAR(20) NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    is_system_template BOOLEAN DEFAULT FALSE
);

-- Alert escalation rules
CREATE TABLE alert_escalations (
    id BIGSERIAL PRIMARY KEY,
    alert_rule_id BIGINT REFERENCES alert_rules(id) NOT NULL,
    escalation_level INTEGER NOT NULL, -- 1, 2, 3 for multiple levels
    delay_minutes INTEGER NOT NULL, -- minutes before escalation
    escalation_recipients TEXT[] NOT NULL,
    escalation_message TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);
```

**Subscription Integration:** Professional tier validation [Source: architecture/7-database-schema-bangkok-dataset-optimized.md]
```sql
CREATE TABLE subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id),
    tier VARCHAR(20) NOT NULL DEFAULT 'free',
    stripe_subscription_id VARCHAR(100),
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ
);
```

**Bangkok Dataset Context:**
- 134 sensors across 7 floors requiring efficient alert evaluation [Source: architecture/1-bangkok-dataset-integration-pipeline.md]
- 18 months of historical data (2018-2019) for threshold validation and baseline establishment
- Equipment types include HVAC, lighting, power systems with distinct failure patterns
- Real-time sensor data ingestion pipeline for continuous alert monitoring

### API Specifications
**Alert Management Endpoints:** [Source: architecture/8-api-architecture.md pattern]
```typescript
// Alert rule management
POST /api/alerts/rules - Create new alert rule (Professional tier only)
Body: {
  name: string,
  sensor_id: string,
  threshold_type: 'value' | 'deviation' | 'trend',
  threshold_config: {
    min_value?: number,
    max_value?: number,
    deviation_percent?: number,
    time_window_minutes?: number
  },
  severity: 'critical' | 'warning' | 'info',
  notification_channels: string[],
  email_recipients?: string[]
}

GET /api/alerts/rules - List user's alert rules with filtering
Query: sensor_id?, equipment_type?, severity?, is_active?

PUT /api/alerts/rules/{rule_id} - Update alert rule (Professional tier only)
DELETE /api/alerts/rules/{rule_id} - Delete alert rule (Professional tier only)

// Active alert management  
GET /api/alerts/instances - List active and historical alerts
Query: status?, severity?, sensor_id?, date_range?

POST /api/alerts/instances/{instance_id}/acknowledge - Acknowledge alert
Body: { notes?: string }

POST /api/alerts/instances/{instance_id}/resolve - Resolve alert
Body: { resolution_notes: string }

// Alert templates
GET /api/alerts/templates - List available alert templates
Body: { equipment_type?: string }

POST /api/alerts/templates/apply - Apply template to create alert rule
Body: { template_id: string, sensor_ids: string[], customizations?: object }

// Real-time notifications
GET /api/alerts/notifications/stream - WebSocket endpoint for real-time alerts
WebSocket: Authenticated connection with alert instance updates

// Alert analytics
GET /api/alerts/analytics - Alert statistics and trends
Query: time_range?, sensor_id?, equipment_type?
Returns: { alert_count, resolution_time_avg, top_failing_sensors }
```

**Professional Tier Restrictions:** [Source: architecture/8-api-architecture.md]
- All alert rule CRUD operations require Professional subscription validation
- Free tier users get read-only access to system-generated basic alerts only
- Subscription middleware validates tier access on all alert configuration endpoints
- Graceful degradation disables alert rules when subscription expires

**Rate Limiting Implementation:** [Source: architecture/8-api-architecture.md]
- Professional tier: 10,000 requests/hour for alert API access
- Alert evaluation background jobs optimized to stay within Supabase query limits
- Email notification rate limiting based on email service provider quotas
- WebSocket connection limits per user to prevent resource exhaustion

### Component Specifications
**Alert Components Location:** `src/components/features/alerts/` [Source: architecture/source-tree.md pattern]

**Required UI Components:**
- `AlertRulesList.tsx` - Display and manage user's alert rules with filtering and status
- `AlertRuleForm.tsx` - Create and edit alert rules with threshold configuration
- `SensorSelector.tsx` - Sensor selection interface with floor and equipment type organization  
- `ThresholdConfigurator.tsx` - Threshold setting interface with validation and preview
- `AlertTemplateSelector.tsx` - Apply predefined alert templates for common scenarios
- `ActiveAlertsDashboard.tsx` - Real-time display of active alerts with acknowledgment actions
- `AlertHistory.tsx` - Historical alert analysis with resolution tracking and patterns
- `NotificationSettings.tsx` - Configure notification preferences and recipients
- `AlertAnalytics.tsx` - Alert statistics and performance metrics for optimization

**Real-time Notification Components:**
- `AlertNotificationCenter.tsx` - In-app notification display with alert management
- `AlertToast.tsx` - Toast notifications for real-time alert delivery
- `BrowserNotificationManager.tsx` - Browser notification API integration with permission handling
- `AlertSoundManager.tsx` - Audio alerts for critical notifications with user preferences

**Professional Tier Components:**
- `SubscriptionAlertGate.tsx` - Professional tier access control with upgrade promotion
- `AlertFeaturePromo.tsx` - Free tier user interface promoting alert features
- `SubscriptionUpgradeModal.tsx` - Upgrade flow specifically for alert feature access

**Chart Integration Components:**
- Reuse existing chart components for alert threshold visualization [Source: architecture/source-tree.md pattern]
- `ThresholdVisualization.tsx` - Display thresholds overlaid on sensor data charts  
- `AlertTrendChart.tsx` - Historical alert frequency and resolution time analysis

### File Locations
**Component Files:** [Source: architecture/source-tree.md pattern]
- `src/components/features/alerts/AlertRulesList.tsx`
- `src/components/features/alerts/AlertRuleForm.tsx`
- `src/components/features/alerts/SensorSelector.tsx`
- `src/components/features/alerts/ThresholdConfigurator.tsx`
- `src/components/features/alerts/ActiveAlertsDashboard.tsx`
- `src/components/features/alerts/AlertHistory.tsx`
- `src/components/features/alerts/NotificationSettings.tsx`
- `src/components/ui/notifications/AlertNotificationCenter.tsx`
- `src/components/ui/notifications/AlertToast.tsx`

**API Route Files:**
- `src/app/api/alerts/rules/route.ts` - Alert rule CRUD operations
- `src/app/api/alerts/rules/[rule_id]/route.ts` - Individual rule management
- `src/app/api/alerts/instances/route.ts` - Alert instance queries
- `src/app/api/alerts/instances/[instance_id]/acknowledge/route.ts` - Alert acknowledgment
- `src/app/api/alerts/instances/[instance_id]/resolve/route.ts` - Alert resolution
- `src/app/api/alerts/templates/route.ts` - Alert templates management
- `src/app/api/alerts/notifications/stream/route.ts` - WebSocket real-time notifications
- `src/app/api/alerts/analytics/route.ts` - Alert analytics and reporting

**Utility Files:**
- `src/lib/alerts/alertEvaluator.ts` - Alert threshold evaluation logic
- `src/lib/alerts/notificationService.ts` - Email and in-app notification delivery
- `src/lib/alerts/escalationManager.ts` - Alert escalation and acknowledgment logic
- `src/lib/alerts/templateManager.ts` - Alert template processing and application
- `src/lib/alerts/realTimeNotifications.ts` - WebSocket alert delivery management
- `src/lib/alerts/subscriptionValidator.ts` - Professional tier access validation
- `src/lib/alerts/alertAnalytics.ts` - Alert statistics and trend analysis

**Hook Files:**
- `src/hooks/useAlertRules.ts` - Alert rule management with CRUD operations
- `src/hooks/useActiveAlerts.ts` - Active alert monitoring with real-time updates
- `src/hooks/useAlertNotifications.ts` - Notification management and delivery tracking
- `src/hooks/useAlertSubscription.ts` - Professional tier validation and upgrade prompts
- `src/hooks/useRealTimeAlerts.ts` - WebSocket connection and real-time alert handling

**Type Definitions:**
- `src/types/alerts.ts` - Alert rule, instance, and notification type definitions [Source: architecture/source-tree.md pattern]
- `src/types/notifications.ts` - Notification system type definitions
- `src/types/alertAnalytics.ts` - Alert statistics and analytics type definitions

### Testing Standards
**Test Coverage:** 85% minimum, 100% for alert evaluation and notification business logic [Source: architecture/5-testing-framework-setup-installation.md]

**Critical Test Scenarios:**
- Alert evaluation performance with Bangkok dataset scale (134 sensors)
- Real-time notification delivery under high alert frequency conditions  
- Email delivery reliability with bounce handling and retry logic
- Professional tier subscription validation and graceful degradation
- Alert acknowledgment and resolution workflow integrity
- WebSocket connection stability and automatic reconnection
- Alert escalation timing and recipient management accuracy

**Required Test Types:** [Source: architecture/5-testing-framework-setup-installation.md]
- Unit Tests: Alert evaluation logic, notification formatters, subscription validators
- Integration Tests: API endpoints with database operations and email delivery
- E2E Tests: Complete alert lifecycle from configuration through resolution
- Performance Tests: High-frequency alert evaluation and concurrent notification delivery
- Real-time Tests: WebSocket connection handling and notification synchronization

**Test Files Location:** [Source: architecture/source-tree.md pattern]
- `__tests__/lib/alerts/alertEvaluator.test.ts`
- `__tests__/lib/alerts/notificationService.test.ts`
- `__tests__/components/alerts/AlertRuleForm.test.tsx`
- `__tests__/api/alerts/rules.test.ts`
- `__tests__/hooks/useAlertRules.test.ts`
- `__tests__/integration/alertWorkflow.test.ts`
- `__tests__/e2e/alertConfiguration.spec.ts`

### Technical Constraints
**Performance Requirements:** [Source: architecture/tech-stack.md, architecture/10-monitoring-observability.md]
- Alert evaluation latency: <30 seconds from sensor data to notification
- Real-time notification delivery: <5 seconds via WebSocket
- Email notification delivery: <2 minutes with delivery confirmation
- Alert dashboard loading: <2 seconds for alert history and active alerts
- Concurrent user support: 100+ simultaneous users without degradation

**Bangkok Dataset Constraints:** [Source: architecture/1-bangkok-dataset-integration-pipeline.md]
- 134 sensors requiring efficient alert evaluation without database overload
- 18 months historical data for threshold baseline calculation
- Real-time data ingestion pipeline integration for continuous monitoring
- Equipment type diversity requiring flexible threshold configuration

**Technology Constraints:** [Source: architecture/tech-stack.md]
- Next.js 14+ App Router for API routes and WebSocket handling
- Supabase PostgreSQL with Row Level Security for multi-tenant alert isolation
- TypeScript strict mode for type safety in alert evaluation logic
- Real-time subscriptions via Supabase real-time or WebSocket implementation

**Email Service Constraints:** [Source: architecture/8-api-architecture.md]
- Email service integration for alert notifications (specific provider not defined)
- Rate limiting: 3K emails/month free tier, 100 emails/day operational limit
- Bounce handling and delivery confirmation for notification reliability
- Template support for branded alert notifications

**Subscription Integration Constraints:** [Source: architecture/tech-stack.md]
- Stripe subscription validation for Professional tier features
- Real-time subscription status checking for alert system access
- Graceful degradation when subscription expires during active alerts
- Professional tier exclusive access with Free tier feature promotion

## Project Structure Notes

**Alignment Verified:** All file paths and component locations align with the defined project structure in `source-tree.md`. New alerts-specific directories created under established analytics and API structures following the pattern from export functionality in Story 3.4.

**Key Structural Additions:**
- New `alerts/` subdirectory under `src/components/features/` for alert-specific UI components
- Alert utility files organized in `src/lib/alerts/` following the same pattern as export utilities
- API routes following Next.js App Router pattern with nested alert endpoints matching existing patterns
- Alert-specific hooks in `src/hooks/` directory maintaining consistency with existing hook organization
- Notification components in `src/components/ui/notifications/` for reusable notification UI elements

**Database Schema Integration:**
- New alert management tables integrate with existing `auth.users` table for user relationships
- Maintains relationships with `sensor_readings` table for real-time monitoring
- Subscription validation through existing `subscriptions` table for Professional tier access
- Follows established RLS policy patterns and naming conventions from existing schema

**Real-time Architecture Integration:**
- WebSocket endpoints follow Next.js App Router WebSocket handling patterns
- Real-time notification system integrates with existing dashboard real-time capabilities
- Notification components reuse established UI patterns and styling from existing components

**Email Service Integration:**
- Email notification system follows the same patterns established in Story 3.4 export functionality
- Template system reuses existing email template infrastructure with alert-specific customizations
- Delivery confirmation and bounce handling leverages existing email service integration patterns

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-09-11 | 1.0 | Initial story creation with comprehensive technical context | BMAD Scrum Master |

## Dev Agent Record

*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be populated during development*

### Debug Log References  
*To be populated during development*

### Completion Notes List
*To be populated during development*

### File List
*To be populated during development*

## QA Results

*Results from QA Agent review will be populated here after implementation*