# Story 2.6: Data Trust & Recovery

## Epic: Bangkok Dataset Value Delivery (Week 2 of 3-week MVP)
**Story Points**: 3 points
**Priority**: P1 (Essential for user trust)
**Epic Alignment**: Epic 2 - Bangkok Dataset Value Delivery

---

## User Story

**As a** facility manager relying on CU-BEMS analytics for critical building decisions
**I want** clear indicators of data quality, freshness, and system reliability with graceful degradation during outages
**So that** I can trust the platform for emergency decisions and understand when data limitations might affect insights

---

## Business Context

Trust is the foundation of the €29/month Professional tier value proposition. Facility managers making critical decisions based on Bangkok dataset insights need transparency about data quality, freshness, and system status. This story ensures users maintain confidence in platform reliability while providing fallback capabilities during outages, preventing churn and supporting emergency use cases.

**Business Impact**: Protects user trust and reduces churn by providing transparency about data reliability and maintaining partial functionality during system issues. Essential for establishing platform credibility that supports subscription retention and word-of-mouth recommendations.

---

## CRITICAL REVENUE PROTECTION UPDATE

**PO VALIDATION FINDINGS**: This story had major revenue protection gaps where Free tier users could access Professional-level cached data during outages, undermining the €29/month subscription model.

### Major Revenue Protection Issues Identified:
1. **No subscription tier consideration** in cache prioritization
2. **No restrictions on cached data access** by subscription tier
3. **No Professional tier benefits** during outages
4. **Risk**: Free tier users accessing Professional-level cached data during outages

### Required Revenue Protection Controls:

1. **Tier-Based Cache Strategy**
   - Free tier cache limited to 30-day Bangkok data restrictions (same as live data)
   - Professional tier cache includes full 18-month dataset access
   - Cache eviction prioritizes Professional tier data retention

2. **Subscription-Aware Service Recovery**
   - Professional subscribers get priority during outage recovery
   - Free tier users see upgrade prompts during degraded service
   - Different service levels during outages based on subscription

3. **Trust-Building Conversion Opportunities**
   - Use data quality indicators as upgrade touchpoints
   - Professional tier offers better reliability guarantees
   - System status differences highlight Professional tier benefits

---

## Acceptance Criteria

### AC1: Data Quality Indicators
**Given** a user views Bangkok dataset insights on any dashboard component
**When** they need to assess data reliability for decision-making
**Then** they should see clear data quality indicators showing completeness, freshness, and validation status
**And** they should understand any limitations that might affect insight accuracy
**And** they should see data source attribution for transparency

**Technical Requirements**:
- Real-time data quality badges on all dashboard components
- Freshness timestamps with clear aging indicators (last updated X hours ago)
- Completeness percentages for sensor data availability
- Validation status indicators (validated, processing, issues detected)
- Data source transparency (Bangkok University 2018-2019 attribution)
- Quality score calculation and display (0-100% reliability score)

### AC2: System Status Dashboard
**Given** a user accesses the platform during normal or degraded operations
**When** they need to understand system reliability and any service limitations
**Then** they should see clear system status information with operational details
**And** they should understand how any issues might affect their analytics
**And** they should receive proactive notifications about service changes

**Technical Requirements**:
- System status page showing all service components (API, database, analytics engine)
- Real-time uptime monitoring with historical performance data
- Service degradation notifications with impact descriptions
- Planned maintenance announcements with advance notice
- Component-level status indicators (operational, degraded, maintenance, outage)
- Response time metrics for key services (<500ms API target)

### AC3: Cached Data Display During Outages
**Given** the platform experiences API outages or degraded service
**When** users attempt to access Bangkok dataset insights
**Then** they should see cached data with clear staleness indicators
**And** they should understand the age and reliability of cached information
**And** they should maintain access to critical building analytics for emergency decisions

**Technical Requirements**:
- Intelligent caching strategy prioritizing most recent and critical data
- Cache freshness indicators showing data age (cached 2 hours ago)
- Automatic fallback to cached data during API failures
- Cache quality scoring based on data completeness and age
- Emergency access mode highlighting available vs unavailable features
- Progressive degradation with graceful feature reduction

### AC4: Loading States with Data Freshness
**Given** a user navigates to any analytics view while data is loading
**When** the system retrieves Bangkok dataset information
**Then** they should see informative loading states with freshness context
**And** they should understand expected wait times and data characteristics
**And** they should see progressive loading with partial data display

**Technical Requirements**:
- Skeleton UI components showing expected content structure
- Progressive loading with partial data display as available
- Loading time estimates based on data complexity
- Freshness indicators during load (loading latest data from 2 hours ago)
- Error handling with clear retry options and fallback data
- Performance monitoring ensuring <3s dashboard load times

---

## Technical Implementation Details

### 1. Data Quality Service
```typescript
// src/lib/data-quality/quality-service.ts
import { createServerComponentClient } from '@supabase/auth-helpers-nextjs'

export interface DataQualityMetrics {
  overall_score: number // 0-100
  completeness: number // % of expected data points available
  freshness_minutes: number // minutes since last update
  validation_status: 'validated' | 'processing' | 'issues' | 'stale'
  sensor_availability: {
    total_sensors: number
    active_sensors: number
    failed_sensors: number
  }
  last_update: string
  data_source: {
    name: string
    period: string
    attribution: string
  }
}

export interface SystemStatus {
  api_status: 'operational' | 'degraded' | 'maintenance' | 'outage'
  database_status: 'operational' | 'degraded' | 'maintenance' | 'outage'
  analytics_status: 'operational' | 'degraded' | 'maintenance' | 'outage'
  cache_status: 'operational' | 'degraded' | 'maintenance' | 'outage'
  last_updated: string
  response_times: {
    api_avg_ms: number
    database_avg_ms: number
    analytics_avg_ms: number
  }
  uptime_percentage: number
}

export class DataQualityService {
  private supabase = createServerComponentClient()

  async getDataQuality(): Promise<DataQualityMetrics> {
    try {
      // Check data freshness from latest readings
      const { data: latestReading, error: readingError } = await this.supabase
        .from('sensor_readings')
        .select('created_at')
        .order('created_at', { ascending: false })
        .limit(1)
        .single()

      if (readingError) {
        throw new Error(`Failed to fetch latest reading: ${readingError.message}`)
      }

      // Calculate freshness in minutes
      const freshness = Math.floor(
        (Date.now() - new Date(latestReading.created_at).getTime()) / (1000 * 60)
      )

      // Check sensor availability
      const { data: sensorStats, error: sensorError } = await this.supabase
        .from('sensor_health')
        .select('*')
        .single()

      if (sensorError) {
        console.warn('Failed to fetch sensor stats:', sensorError)
      }

      // Calculate completeness based on expected data points
      const expectedDailyReadings = 144 * 288 // 144 sensors * 5-min intervals per day
      const { data: dailyCount, error: countError } = await this.supabase
        .from('sensor_readings')
        .select('*', { count: 'exact', head: true })
        .gte('created_at', new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString())

      const completeness = countError ? 0 : Math.min(
        ((dailyCount?.length || 0) / expectedDailyReadings) * 100,
        100
      )

      // Determine validation status
      let validationStatus: DataQualityMetrics['validation_status'] = 'validated'
      if (freshness > 60) validationStatus = 'stale'
      else if (completeness < 80) validationStatus = 'issues'
      else if (completeness < 95) validationStatus = 'processing'

      // Calculate overall quality score
      const freshnessScore = Math.max(0, 100 - (freshness / 60) * 50) // Degrade over 1 hour
      const overallScore = Math.round((completeness + freshnessScore) / 2)

      return {
        overall_score: overallScore,
        completeness: Math.round(completeness),
        freshness_minutes: freshness,
        validation_status: validationStatus,
        sensor_availability: {
          total_sensors: 144,
          active_sensors: sensorStats?.active_sensors || 144,
          failed_sensors: sensorStats?.failed_sensors || 0
        },
        last_update: latestReading.created_at,
        data_source: {
          name: 'Bangkok University Building IoT Dataset',
          period: 'January 2018 - June 2019',
          attribution: 'Bangkok University Faculty of Engineering'
        }
      }
    } catch (error) {
      console.error('Failed to calculate data quality:', error)

      // Return degraded quality metrics
      return {
        overall_score: 50,
        completeness: 0,
        freshness_minutes: 999,
        validation_status: 'issues',
        sensor_availability: {
          total_sensors: 144,
          active_sensors: 0,
          failed_sensors: 144
        },
        last_update: new Date().toISOString(),
        data_source: {
          name: 'Bangkok University Building IoT Dataset',
          period: 'January 2018 - June 2019',
          attribution: 'Bangkok University Faculty of Engineering'
        }
      }
    }
  }

  async getSystemStatus(): Promise<SystemStatus> {
    try {
      // Check API health
      const apiStart = Date.now()
      const { error: apiError } = await this.supabase
        .from('sensor_readings')
        .select('id')
        .limit(1)
      const apiTime = Date.now() - apiStart

      // Check system health from monitoring table
      const { data: healthData, error: healthError } = await this.supabase
        .from('system_health')
        .select('*')
        .order('created_at', { ascending: false })
        .limit(1)
        .single()

      const health = healthData || {
        api_status: apiError ? 'outage' : 'operational',
        database_status: 'operational',
        analytics_status: 'operational',
        cache_status: 'operational',
        api_response_time: apiTime,
        database_response_time: 50,
        analytics_response_time: 100,
        uptime_percentage: 99.9
      }

      return {
        api_status: health.api_status,
        database_status: health.database_status,
        analytics_status: health.analytics_status,
        cache_status: health.cache_status,
        last_updated: new Date().toISOString(),
        response_times: {
          api_avg_ms: health.api_response_time || apiTime,
          database_avg_ms: health.database_response_time || 50,
          analytics_avg_ms: health.analytics_response_time || 100
        },
        uptime_percentage: health.uptime_percentage || 99.9
      }
    } catch (error) {
      console.error('Failed to get system status:', error)

      return {
        api_status: 'outage',
        database_status: 'outage',
        analytics_status: 'outage',
        cache_status: 'outage',
        last_updated: new Date().toISOString(),
        response_times: {
          api_avg_ms: 999,
          database_avg_ms: 999,
          analytics_avg_ms: 999
        },
        uptime_percentage: 0
      }
    }
  }
}
```

### 2. Data Quality Indicator Components
```typescript
// src/components/trust/DataQualityIndicator.tsx
'use client'

import { useEffect, useState } from 'react'
import { Badge } from '@/components/ui/Badge'
import {
  CheckCircleIcon,
  ClockIcon,
  AlertTriangleIcon,
  XCircleIcon,
  InfoIcon
} from 'lucide-react'
import { DataQualityMetrics } from '@/lib/data-quality/quality-service'

interface DataQualityIndicatorProps {
  compact?: boolean
  showDetails?: boolean
}

export function DataQualityIndicator({ compact = false, showDetails = true }: DataQualityIndicatorProps) {
  const [quality, setQuality] = useState<DataQualityMetrics | null>(null)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    async function fetchQuality() {
      try {
        const response = await fetch('/api/system/data-quality')
        const data = await response.json()
        if (data.success) {
          setQuality(data.quality)
        }
      } catch (error) {
        console.error('Failed to fetch data quality:', error)
      } finally {
        setLoading(false)
      }
    }

    fetchQuality()
    const interval = setInterval(fetchQuality, 60000) // Update every minute

    return () => clearInterval(interval)
  }, [])

  if (loading) {
    return (
      <div className="flex items-center gap-2">
        <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
        <span className="text-sm text-gray-500">Checking data quality...</span>
      </div>
    )
  }

  if (!quality) {
    return (
      <Badge variant="destructive" className="flex items-center gap-1">
        <XCircleIcon className="w-3 h-3" />
        Data Unavailable
      </Badge>
    )
  }

  const getQualityColor = (score: number) => {
    if (score >= 90) return 'text-green-600'
    if (score >= 70) return 'text-yellow-600'
    return 'text-red-600'
  }

  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'validated':
        return <CheckCircleIcon className="w-3 h-3 text-green-600" />
      case 'processing':
        return <ClockIcon className="w-3 h-3 text-yellow-600" />
      case 'issues':
        return <AlertTriangleIcon className="w-3 h-3 text-orange-600" />
      case 'stale':
        return <XCircleIcon className="w-3 h-3 text-red-600" />
      default:
        return <InfoIcon className="w-3 h-3 text-gray-600" />
    }
  }

  const getStatusText = (status: string) => {
    switch (status) {
      case 'validated':
        return 'Validated'
      case 'processing':
        return 'Processing'
      case 'issues':
        return 'Issues Detected'
      case 'stale':
        return 'Stale Data'
      default:
        return 'Unknown'
    }
  }

  const formatFreshness = (minutes: number) => {
    if (minutes < 60) return `${minutes}m ago`
    const hours = Math.floor(minutes / 60)
    if (hours < 24) return `${hours}h ago`
    const days = Math.floor(hours / 24)
    return `${days}d ago`
  }

  if (compact) {
    return (
      <div className="flex items-center gap-2">
        <div className={`text-sm font-medium ${getQualityColor(quality.overall_score)}`}>
          {quality.overall_score}%
        </div>
        {getStatusIcon(quality.validation_status)}
      </div>
    )
  }

  return (
    <div className="bg-white border border-gray-200 rounded-lg p-4">
      <div className="flex items-center justify-between mb-3">
        <h3 className="font-semibold text-gray-900">Data Quality</h3>
        <Badge
          variant={quality.overall_score >= 90 ? 'success' : quality.overall_score >= 70 ? 'warning' : 'destructive'}
          className="flex items-center gap-1"
        >
          {getStatusIcon(quality.validation_status)}
          {getStatusText(quality.validation_status)}
        </Badge>
      </div>

      <div className="grid grid-cols-2 md:grid-cols-4 gap-3 mb-4">
        <div className="text-center">
          <div className={`text-2xl font-bold ${getQualityColor(quality.overall_score)}`}>
            {quality.overall_score}%
          </div>
          <div className="text-xs text-gray-500">Overall Quality</div>
        </div>
        <div className="text-center">
          <div className="text-2xl font-bold text-blue-600">
            {quality.completeness}%
          </div>
          <div className="text-xs text-gray-500">Data Completeness</div>
        </div>
        <div className="text-center">
          <div className="text-2xl font-bold text-purple-600">
            {quality.sensor_availability.active_sensors}
          </div>
          <div className="text-xs text-gray-500">Active Sensors</div>
        </div>
        <div className="text-center">
          <div className="text-lg font-bold text-gray-600">
            {formatFreshness(quality.freshness_minutes)}
          </div>
          <div className="text-xs text-gray-500">Last Update</div>
        </div>
      </div>

      {showDetails && (
        <div className="border-t border-gray-200 pt-3">
          <div className="text-sm text-gray-600 space-y-1">
            <div className="flex justify-between">
              <span>Data Source:</span>
              <span className="font-medium">{quality.data_source.name}</span>
            </div>
            <div className="flex justify-between">
              <span>Period:</span>
              <span className="font-medium">{quality.data_source.period}</span>
            </div>
            <div className="flex justify-between">
              <span>Total Sensors:</span>
              <span className="font-medium">
                {quality.sensor_availability.active_sensors}/{quality.sensor_availability.total_sensors}
              </span>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}
```

### 3. System Status Component
```typescript
// src/components/trust/SystemStatus.tsx
'use client'

import { useEffect, useState } from 'react'
import { Badge } from '@/components/ui/Badge'
import { Button } from '@/components/ui/Button'
import {
  CheckCircleIcon,
  AlertTriangleIcon,
  XCircleIcon,
  RefreshCwIcon,
  ClockIcon
} from 'lucide-react'
import { SystemStatus as SystemStatusType } from '@/lib/data-quality/quality-service'

export function SystemStatus() {
  const [status, setStatus] = useState<SystemStatusType | null>(null)
  const [loading, setLoading] = useState(true)
  const [lastRefresh, setLastRefresh] = useState<Date>(new Date())

  useEffect(() => {
    async function fetchStatus() {
      try {
        const response = await fetch('/api/system/status')
        const data = await response.json()
        if (data.success) {
          setStatus(data.status)
          setLastRefresh(new Date())
        }
      } catch (error) {
        console.error('Failed to fetch system status:', error)
      } finally {
        setLoading(false)
      }
    }

    fetchStatus()
    const interval = setInterval(fetchStatus, 30000) // Update every 30 seconds

    return () => clearInterval(interval)
  }, [])

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'operational': return 'text-green-600'
      case 'degraded': return 'text-yellow-600'
      case 'maintenance': return 'text-blue-600'
      case 'outage': return 'text-red-600'
      default: return 'text-gray-600'
    }
  }

  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'operational':
        return <CheckCircleIcon className="w-4 h-4 text-green-600" />
      case 'degraded':
        return <AlertTriangleIcon className="w-4 h-4 text-yellow-600" />
      case 'maintenance':
        return <ClockIcon className="w-4 h-4 text-blue-600" />
      case 'outage':
        return <XCircleIcon className="w-4 h-4 text-red-600" />
      default:
        return <AlertTriangleIcon className="w-4 h-4 text-gray-600" />
    }
  }

  const getStatusText = (status: string) => {
    switch (status) {
      case 'operational': return 'Operational'
      case 'degraded': return 'Degraded'
      case 'maintenance': return 'Maintenance'
      case 'outage': return 'Outage'
      default: return 'Unknown'
    }
  }

  const refreshStatus = () => {
    setLoading(true)
    // Trigger refresh
    setLastRefresh(new Date())
  }

  if (loading) {
    return (
      <div className="bg-white border border-gray-200 rounded-lg p-4">
        <div className="flex items-center gap-2 mb-4">
          <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
          <span className="font-semibold text-gray-900">Checking System Status...</span>
        </div>
      </div>
    )
  }

  if (!status) {
    return (
      <div className="bg-red-50 border border-red-200 rounded-lg p-4">
        <div className="flex items-center gap-2 mb-2">
          <XCircleIcon className="w-5 h-5 text-red-600" />
          <span className="font-semibold text-red-800">System Status Unavailable</span>
        </div>
        <p className="text-sm text-red-700">
          Unable to retrieve system status. Some features may be limited.
        </p>
      </div>
    )
  }

  const overallHealthy = [
    status.api_status,
    status.database_status,
    status.analytics_status,
    status.cache_status
  ].every(s => s === 'operational')

  return (
    <div className="bg-white border border-gray-200 rounded-lg p-4">
      <div className="flex items-center justify-between mb-4">
        <div className="flex items-center gap-2">
          <h3 className="font-semibold text-gray-900">System Status</h3>
          {overallHealthy ? (
            <Badge variant="success" className="flex items-center gap-1">
              <CheckCircleIcon className="w-3 h-3" />
              All Systems Operational
            </Badge>
          ) : (
            <Badge variant="warning" className="flex items-center gap-1">
              <AlertTriangleIcon className="w-3 h-3" />
              Some Issues Detected
            </Badge>
          )}
        </div>
        <Button variant="ghost" size="sm" onClick={refreshStatus}>
          <RefreshCwIcon className="w-4 h-4" />
        </Button>
      </div>

      <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
        <div className="flex items-center gap-2">
          {getStatusIcon(status.api_status)}
          <div>
            <div className="text-sm font-medium">API</div>
            <div className={`text-xs ${getStatusColor(status.api_status)}`}>
              {getStatusText(status.api_status)}
            </div>
          </div>
        </div>
        <div className="flex items-center gap-2">
          {getStatusIcon(status.database_status)}
          <div>
            <div className="text-sm font-medium">Database</div>
            <div className={`text-xs ${getStatusColor(status.database_status)}`}>
              {getStatusText(status.database_status)}
            </div>
          </div>
        </div>
        <div className="flex items-center gap-2">
          {getStatusIcon(status.analytics_status)}
          <div>
            <div className="text-sm font-medium">Analytics</div>
            <div className={`text-xs ${getStatusColor(status.analytics_status)}`}>
              {getStatusText(status.analytics_status)}
            </div>
          </div>
        </div>
        <div className="flex items-center gap-2">
          {getStatusIcon(status.cache_status)}
          <div>
            <div className="text-sm font-medium">Cache</div>
            <div className={`text-xs ${getStatusColor(status.cache_status)}`}>
              {getStatusText(status.cache_status)}
            </div>
          </div>
        </div>
      </div>

      <div className="border-t border-gray-200 pt-3">
        <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
          <div>
            <div className="text-gray-500">API Response</div>
            <div className="font-medium">{status.response_times.api_avg_ms}ms</div>
          </div>
          <div>
            <div className="text-gray-500">Database</div>
            <div className="font-medium">{status.response_times.database_avg_ms}ms</div>
          </div>
          <div>
            <div className="text-gray-500">Analytics</div>
            <div className="font-medium">{status.response_times.analytics_avg_ms}ms</div>
          </div>
          <div>
            <div className="text-gray-500">Uptime</div>
            <div className="font-medium">{status.uptime_percentage}%</div>
          </div>
        </div>
        <div className="mt-2 text-xs text-gray-500">
          Last updated: {lastRefresh.toLocaleTimeString()}
        </div>
      </div>
    </div>
  )
}
```

### 4. Cached Data Display Component
```typescript
// src/components/trust/CachedDataIndicator.tsx
'use client'

import { ReactNode } from 'react'
import { Badge } from '@/components/ui/Badge'
import { Button } from '@/components/ui/Button'
import { CloudOffIcon, RefreshCwIcon, AlertTriangleIcon } from 'lucide-react'

interface CachedDataIndicatorProps {
  children: ReactNode
  cacheAge: number // minutes
  isStale: boolean
  onRefresh?: () => void
  refreshing?: boolean
}

export function CachedDataIndicator({
  children,
  cacheAge,
  isStale,
  onRefresh,
  refreshing = false
}: CachedDataIndicatorProps) {
  const formatCacheAge = (minutes: number) => {
    if (minutes < 60) return `${minutes} minutes ago`
    const hours = Math.floor(minutes / 60)
    if (hours < 24) return `${hours} hours ago`
    const days = Math.floor(hours / 24)
    return `${days} days ago`
  }

  const getCacheQuality = (minutes: number) => {
    if (minutes < 15) return { color: 'green', label: 'Fresh' }
    if (minutes < 60) return { color: 'yellow', label: 'Recent' }
    if (minutes < 240) return { color: 'orange', label: 'Aging' }
    return { color: 'red', label: 'Stale' }
  }

  const cacheQuality = getCacheQuality(cacheAge)

  return (
    <div className="relative">
      {/* Cache Warning Banner */}
      <div className={`
        border-l-4 mb-4 p-3 rounded-r-lg
        ${isStale
          ? 'bg-red-50 border-red-400'
          : cacheAge > 60
            ? 'bg-yellow-50 border-yellow-400'
            : 'bg-blue-50 border-blue-400'
        }
      `}>
        <div className="flex items-center gap-2 mb-2">
          <CloudOffIcon className={`
            w-4 h-4
            ${isStale
              ? 'text-red-600'
              : cacheAge > 60
                ? 'text-yellow-600'
                : 'text-blue-600'
            }
          `} />
          <span className={`
            font-medium text-sm
            ${isStale
              ? 'text-red-800'
              : cacheAge > 60
                ? 'text-yellow-800'
                : 'text-blue-800'
            }
          `}>
            {isStale ? 'Displaying Cached Data' : 'Live Data Temporarily Unavailable'}
          </span>
          <Badge
            variant={isStale ? 'destructive' : cacheAge > 60 ? 'warning' : 'secondary'}
            className="text-xs"
          >
            {cacheQuality.label}
          </Badge>
        </div>

        <div className="flex items-center justify-between">
          <div className={`
            text-sm
            ${isStale
              ? 'text-red-700'
              : cacheAge > 60
                ? 'text-yellow-700'
                : 'text-blue-700'
            }
          `}>
            Last updated: {formatCacheAge(cacheAge)}
            {isStale && ' • Data may be outdated for current decisions'}
          </div>

          {onRefresh && (
            <Button
              variant="ghost"
              size="sm"
              onClick={onRefresh}
              disabled={refreshing}
              className={`
                ${isStale
                  ? 'text-red-600 hover:text-red-700 hover:bg-red-100'
                  : cacheAge > 60
                    ? 'text-yellow-600 hover:text-yellow-700 hover:bg-yellow-100'
                    : 'text-blue-600 hover:text-blue-700 hover:bg-blue-100'
                }
              `}
            >
              <RefreshCwIcon className={`w-3 h-3 mr-1 ${refreshing ? 'animate-spin' : ''}`} />
              {refreshing ? 'Refreshing...' : 'Try Again'}
            </Button>
          )}
        </div>
      </div>

      {/* Cached Content with Overlay */}
      <div className={`
        relative
        ${isStale ? 'opacity-75' : 'opacity-90'}
      `}>
        {children}

        {/* Subtle overlay for very stale data */}
        {isStale && (
          <div className="absolute inset-0 bg-gray-100 bg-opacity-20 flex items-center justify-center pointer-events-none">
            <div className="bg-white bg-opacity-90 rounded-lg p-3 border border-gray-300 shadow-sm">
              <div className="flex items-center gap-2 text-sm text-gray-600">
                <AlertTriangleIcon className="w-4 h-4" />
                <span>Cached data - Use caution for critical decisions</span>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  )
}
```

---

## Testing Requirements

### Unit Tests
```typescript
// __tests__/trust/data-quality.test.ts
describe('Data Quality Service', () => {
  it('should calculate accurate quality metrics', async () => {
    const service = new DataQualityService()
    const quality = await service.getDataQuality()

    expect(quality.overall_score).toBeGreaterThanOrEqual(0)
    expect(quality.overall_score).toBeLessThanOrEqual(100)
    expect(quality.completeness).toBeGreaterThanOrEqual(0)
    expect(quality.completeness).toBeLessThanOrEqual(100)
    expect(quality.sensor_availability.total_sensors).toBe(144)
  })

  it('should handle system outages gracefully', async () => {
    // Mock database failure
    const service = new DataQualityService()
    const status = await service.getSystemStatus()

    // Should return degraded metrics, not crash
    expect(status).toBeDefined()
    expect(status.api_status).toMatch(/operational|degraded|outage/)
  })

  it('should provide accurate freshness calculations', () => {
    const testTime = new Date('2023-01-01T12:00:00Z')
    const currentTime = new Date('2023-01-01T13:30:00Z')

    const freshness = Math.floor(
      (currentTime.getTime() - testTime.getTime()) / (1000 * 60)
    )

    expect(freshness).toBe(90) // 1.5 hours = 90 minutes
  })
})
```

### Integration Tests
```typescript
// __tests__/integration/trust-recovery.test.tsx
describe('Trust and Recovery System', () => {
  it('should display cached data during API outages', async () => {
    // Mock API failure
    global.fetch = jest.fn(() => Promise.reject(new Error('API Error')))

    render(<DashboardWithTrustIndicators />)

    // Should show cached data indicator
    expect(screen.getByText(/cached data/i)).toBeInTheDocument()
    expect(screen.getByText(/try again/i)).toBeInTheDocument()

    // Should still show some data
    expect(screen.getByText(/building efficiency/i)).toBeInTheDocument()
  })

  it('should transition from cached to live data smoothly', async () => {
    // Start with cached data
    render(<DashboardWithTrustIndicators />)

    expect(screen.getByText(/cached/i)).toBeInTheDocument()

    // Mock successful API call
    global.fetch = jest.fn(() => Promise.resolve({
      ok: true,
      json: () => Promise.resolve({ success: true, data: mockLiveData })
    }))

    // Click refresh
    fireEvent.click(screen.getByText(/try again/i))

    // Should transition to live data
    await waitFor(() => {
      expect(screen.queryByText(/cached/i)).not.toBeInTheDocument()
    })
  })
})
```

---

## Dependencies and Integration Points

### Internal Dependencies
- **Bangkok API**: Real-time data quality assessment
- **Caching Layer**: Intelligent fallback during outages
- **Dashboard Components**: Integration with all metric displays
- **Monitoring System**: System health tracking and alerting

### External Dependencies
- **Lucide React**: v0.294.0 (already in package.json) for status icons
- **SWR**: v2.2.4 (already in package.json) for data fetching with caching
- **React**: Built-in useState and useEffect for component state

### Database Requirements
```sql
-- System health monitoring table
CREATE TABLE IF NOT EXISTS system_health (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  api_status TEXT NOT NULL,
  database_status TEXT NOT NULL,
  analytics_status TEXT NOT NULL,
  cache_status TEXT NOT NULL,
  api_response_time INTEGER,
  database_response_time INTEGER,
  analytics_response_time INTEGER,
  uptime_percentage DECIMAL(5,2),
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Sensor health tracking
CREATE TABLE IF NOT EXISTS sensor_health (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  total_sensors INTEGER DEFAULT 144,
  active_sensors INTEGER,
  failed_sensors INTEGER,
  last_validated TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_system_health_created ON system_health(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_sensor_health_updated ON sensor_health(updated_at DESC);
```

---

## Definition of Done

### Functional Requirements ✅
- [ ] Data quality indicators display on all dashboard components
- [ ] System status monitoring operational with real-time updates
- [ ] Cached data gracefully displayed during outages with clear indicators
- [ ] Loading states provide context about data freshness and expected wait times
- [ ] Users can assess data reliability for decision-making

### User Experience Requirements ✅
- [ ] Trust indicators don't interfere with normal workflow
- [ ] Cache age and quality clearly communicated in plain language
- [ ] System status accessible but not prominent during normal operations
- [ ] Emergency access maintained during partial outages
- [ ] Progressive degradation maintains core functionality

### Business Requirements ✅
- [ ] User trust maintained during system issues
- [ ] Transparency supports subscription retention
- [ ] Emergency decision-making capabilities preserved
- [ ] Data quality communication supports Professional tier credibility

### Technical Requirements ✅
- [ ] Quality calculations accurate and performant (<100ms)
- [ ] Caching strategy preserves most critical insights
- [ ] System monitoring covers all service components
- [ ] Fallback systems activate automatically during outages
- [ ] Recovery processes restore service smoothly

---

## Risk Assessment

### User Trust Risks
- **High Risk**: System outages damaging user confidence in platform reliability
  - **Mitigation**: Proactive status communication, reliable cached data, quick recovery
- **Medium Risk**: Complex trust indicators confusing users
  - **Mitigation**: Simple language, progressive disclosure, contextual help

### Technical Risks
- **Medium Risk**: Cache strategy consuming excessive storage
  - **Mitigation**: Intelligent cache eviction, prioritized data retention
- **Low Risk**: Quality calculations impacting dashboard performance
  - **Mitigation**: Efficient algorithms, background processing, optimized queries

### Business Risks
- **High Risk**: Trust issues leading to subscription cancellations
  - **Mitigation**: Transparent communication, reliable fallbacks, quick issue resolution
- **Medium Risk**: Emergency access limitations affecting critical use cases
  - **Mitigation**: Comprehensive caching, offline-capable core features

---

## Success Metrics

### Trust and Reliability Metrics
- User confidence in platform reliability: >85% trust score in surveys
- Churn rate during system issues: <5% monthly increase
- Emergency access success rate: >90% during outages
- Data quality understanding: >80% correctly interpret quality indicators

### Technical Performance Metrics
- Cache hit rate during outages: >95% for critical data
- Quality calculation performance: <100ms response time
- System status accuracy: >99% uptime detection accuracy
- Recovery time after outages: <5 minutes to full functionality

### User Experience Metrics
- Trust indicator comprehension: >75% understand quality scores
- Cache age interpretation: >80% correctly assess data freshness
- System status engagement: >40% check status during issues
- Fallback usage satisfaction: >70% satisfied with cached data experience

---

## Implementation Timeline

**Day 1**: Data quality service and calculation logic
**Day 2**: Quality indicator components and system status dashboard
**Day 3**: Cached data handling and fallback mechanisms
**Day 4**: Integration with dashboard components and testing
**Day 5**: Performance optimization and user experience validation

**Story Completion**: 3 story points delivered within Epic 2 Week 2 timeline

---

## Future Enhancements

### Advanced Trust Features
- Predictive outage notifications based on system trends
- Historical reliability reports for audit purposes
- Automated quality improvement recommendations
- Integration with facility management alerting systems

### Enhanced Recovery Capabilities
- Offline-first architecture for critical features
- Smart caching based on user behavior patterns
- Progressive web app features for emergency access
- Cross-device sync for cached data and preferences

### Monitoring and Analytics
- Machine learning-based outage prediction
- User behavior analysis during system issues
- Trust score correlation with subscription retention
- Quality trends and improvement tracking over time

This story ensures users maintain trust in the CU-BEMS platform through transparent communication about data quality and reliable fallback mechanisms during outages, directly supporting subscription retention and emergency use cases that are critical for facility managers.