# Story 1.4: Core API Endpoints

## Status
Draft

## Story
**As a** frontend developer,
**I want** RESTful API endpoints that provide access to processed Bangkok dataset through the database schema,
**so that** I can build interactive dashboards with real-time analytics and pattern detection capabilities.

## Acceptance Criteria
1. GET /api/readings/summary returns dashboard overview metrics with building health indicators
2. GET /api/readings/timeseries supports date range filtering and returns time-series data for charts
3. GET /api/readings/patterns identifies and returns failure patterns with severity classification
4. All endpoints return consistent JSON structure with proper error handling
5. Proper HTTP status codes and error responses for all failure scenarios
6. API endpoints respond in <500ms as per performance requirements
7. Rate limiting implemented per subscription tier (100 req/hour free, 10K req/hour professional)
8. Authentication and authorization middleware integrated
9. Input validation using Zod schemas for all request parameters
10. Comprehensive API documentation with OpenAPI/Swagger specifications

## Priority & Effort
**Priority**: P0 (Blocking)
**Effort**: 6 points
**Epic**: Epic 1 - Core Data Foundation

## Tasks / Subtasks
- [ ] Create Next.js API route structure in src/app/api/readings/ (AC: 1,2,3)
  - [ ] Set up route.ts files for each endpoint
  - [ ] Configure TypeScript types for request/response objects
  - [ ] Implement proper HTTP method handling (GET)
- [ ] Implement summary statistics endpoint /api/readings/summary (AC: 1,4,5,6)
  - [ ] Query daily_aggregates materialized view for performance
  - [ ] Calculate building health metrics and key performance indicators  
  - [ ] Return dashboard overview data in consistent JSON format
  - [ ] Add error handling with proper HTTP status codes
- [ ] Implement time-series data endpoint /api/readings/timeseries (AC: 2,4,5,6)
  - [ ] Add date range filtering with validation
  - [ ] Query sensor_readings table with optimized indexes
  - [ ] Implement data aggregation for chart visualization
  - [ ] Support pagination for large datasets
- [ ] Add pattern detection algorithms endpoint /api/readings/patterns (AC: 3,4,5,6)
  - [ ] Implement failure pattern detection logic
  - [ ] Add severity classification (Critical/Warning/Info)
  - [ ] Return patterns with confidence intervals and business impact metrics
  - [ ] Cache pattern results for performance optimization  
- [ ] Implement authentication and authorization middleware (AC: 8)
  - [ ] Integrate NextAuth.js session validation
  - [ ] Add subscription tier checking
  - [ ] Implement proper error responses for unauthorized access
- [ ] Add input validation and rate limiting (AC: 7,9)
  - [ ] Create Zod validation schemas for all endpoints
  - [ ] Implement rate limiting by subscription tier
  - [ ] Add request parameter validation and sanitization
- [ ] Create comprehensive API testing suite (AC: 4,5,6)
  - [ ] Unit tests for each endpoint with Jest and Supertest
  - [ ] Integration tests with test database
  - [ ] Performance tests to validate <500ms response times
  - [ ] Error scenario testing for proper HTTP status codes
- [ ] Generate OpenAPI documentation (AC: 10)
  - [ ] Create OpenAPI/Swagger specifications
  - [ ] Generate interactive API documentation
  - [ ] Add request/response examples and testing interface

## Dev Notes

### Previous Story Insights
Building on the foundation established by:
- Story 1.1: Bangkok dataset processing pipeline provides the source data
- Story 1.2: PostgreSQL database schema with optimized tables and materialized views
- Story 1.3: Supabase integration provides the database client and connection pooling

### Data Models
[Source: architecture/7-database-schema-bangkok-dataset-optimized.md]

**Primary Table**: sensor_readings
- id: BIGSERIAL PRIMARY KEY
- timestamp: TIMESTAMPTZ NOT NULL
- sensor_id: VARCHAR(50) NOT NULL  
- floor_number: INTEGER NOT NULL
- equipment_type: VARCHAR(100)
- reading_value: DECIMAL(10,4)
- unit: VARCHAR(20)
- status: VARCHAR(20) DEFAULT 'normal'

**Performance View**: daily_aggregates (materialized view)
- date: DATE (from timestamp)
- sensor_id: VARCHAR(50)
- floor_number: INTEGER  
- equipment_type: VARCHAR(100)
- avg_value: DECIMAL (average reading value)
- max_value: DECIMAL (maximum reading value)
- min_value: DECIMAL (minimum reading value)
- reading_count: INTEGER (number of readings per day)

**Subscription Table**: subscriptions
- id: UUID PRIMARY KEY
- user_id: UUID (references auth.users)
- tier: VARCHAR(20) DEFAULT 'free'
- stripe_subscription_id: VARCHAR(100)
- status: VARCHAR(20) DEFAULT 'active'
- created_at/expires_at: TIMESTAMPTZ

### API Specifications
[Source: architecture/8-api-architecture.md]

**Core Endpoints**:
- GET /api/readings/summary - Dashboard overview with building health metrics
- GET /api/readings/timeseries - Time-series data with date filtering
- GET /api/readings/patterns - Failure pattern detection with severity levels

**Rate Limiting by Tier**:
- Free tier: 100 requests/hour
- Professional tier: 10,000 requests/hour

**Authentication Requirements**:
- All endpoints require valid NextAuth.js session
- Subscription tier validation for rate limiting
- Row Level Security (RLS) policies in Supabase for data access

**Response Format**:
```typescript
// Success response
{
  data: T, // Endpoint-specific data
  meta?: {
    total?: number,
    page?: number,
    limit?: number
  }
}

// Error response  
{
  error: string,
  code?: string,
  details?: unknown,
  timestamp: string
}
```

### Component Specifications
[Source: architecture/coding-standards.md]

**API Route Structure**:
```typescript
// src/app/api/readings/[endpoint]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function GET(request: NextRequest) {
  // Authentication check
  // Request validation with Zod
  // Business logic
  // Error handling
  // Response formatting
}
```

**Database Client**: Type-safe Supabase client with Database types
**Validation**: Zod schemas for all request parameters
**Error Handling**: Consistent error response format with proper HTTP status codes

### File Locations
[Source: architecture/source-tree.md]

**API Routes**:
- `/src/app/api/readings/summary/route.ts`
- `/src/app/api/readings/timeseries/route.ts` 
- `/src/app/api/readings/patterns/route.ts`

**Types**:
- `/src/types/database.ts` - Database schema types
- `/src/types/analytics.ts` - Analytics data types

**Utilities**:
- `/src/lib/database.ts` - Supabase client configuration
- `/src/lib/validations.ts` - Zod validation schemas
- `/src/lib/utils.ts` - General utility functions

**Tests**:
- `/__tests__/api/readings/` - API endpoint tests
- `/__tests__/lib/` - Utility function tests

### Testing Requirements
[Source: architecture/5-testing-framework-setup-installation.md]

**Coverage Requirements**:
- Unit Tests: 85% minimum coverage
- API Endpoints: 100% happy path + error cases coverage
- Performance Tests: Validate <500ms response times

**Testing Framework**: Jest + Testing Library + Supertest
**Test Database**: Supabase test project with sanitized sample data
**Integration Tests**: Full API endpoint testing with authentication

**Test Structure**:
```typescript
describe('/api/readings/summary', () => {
  it('should return analytics data for authenticated user', async () => {
    // Arrange: Mock authentication and test data
    // Act: Make API request
    // Assert: Validate response format and data
  });
  
  it('should return 401 for unauthenticated requests', async () => {
    // Test unauthorized access
  });
  
  it('should respect rate limiting by tier', async () => {
    // Test rate limiting enforcement
  });
});
```

### Technical Constraints
[Source: architecture/tech-stack.md]

**Performance Requirements**:
- API Response: <500ms average response time
- Concurrent Users: 100+ simultaneous users without degradation
- Database Connection: Connection pooling for optimal performance

**Technology Stack**:
- Runtime: Node.js 18+ (Vercel serverless)
- API Framework: Next.js API Routes (REST)
- Database: Supabase PostgreSQL with materialized views
- Authentication: NextAuth.js + Supabase Auth
- Validation: Zod schemas for all inputs

**Security Requirements**:
- Input validation for all API parameters
- Rate limiting enforcement by subscription tier
- Session-based authentication with secure HTTP-only cookies
- Row Level Security (RLS) policies for data access

### Production Readiness Requirements

**API Failure Handling**:
- Retry logic with exponential backoff for database connections
- Graceful degradation during Supabase outages (cached responses)
- Connection pooling with retry queues for connection limits
- Progressive query simplification (full -> simplified -> cached)

**Service Rate Limit Monitoring**:
- Automated alerts at 80% of Supabase free tier limits (500MB storage, 2GB bandwidth)
- Request rate monitoring with automatic throttling
- Subscription tier usage tracking and upgrade notifications

**Error Logging and Alerting**:
- Comprehensive error logging for all API failures
- Performance monitoring for response times >500ms
- Database query performance tracking and optimization alerts

**Monitoring and Observability**:
- API endpoint performance metrics collection
- Error rate monitoring with threshold alerts
- Database connection health monitoring
- User authentication and authorization audit logging

**Documentation Requirements**:
- OpenAPI/Swagger specifications for all endpoints
- Interactive API documentation with examples
- API testing interface for development and QA
- Operational runbook for API troubleshooting

### Testing

**Test Coverage Requirements**:
- 85% minimum unit test coverage for all API endpoints
- 100% coverage for authentication and authorization logic
- 100% coverage for data validation and error handling
- Performance testing for all endpoints to validate <500ms requirement

**Testing Frameworks and Patterns**:
- Jest for unit testing with Supertest for API endpoint testing  
- React Testing Library patterns for component integration
- Test file naming: `{endpoint}.test.ts` co-located with API routes
- Mock data utilities in `__tests__/__mocks__/` directory

**Test Database Strategy**:
- Supabase test project with sanitized Bangkok dataset sample
- Docker PostgreSQL container for local development testing
- Test data seeding scripts for consistent test environments

**API Testing Requirements**:
- Authentication testing (valid sessions, expired sessions, unauthorized access)
- Input validation testing (valid inputs, invalid inputs, edge cases)
- Rate limiting testing (within limits, exceeding limits, different tiers)
- Error handling testing (database errors, network errors, timeout errors)
- Performance testing (response time validation, concurrent request handling)

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-11 | 1.0 | Initial story creation with comprehensive technical context | BMAD Agent |

## Dev Agent Record

*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*Results from QA Agent review of the completed story implementation*