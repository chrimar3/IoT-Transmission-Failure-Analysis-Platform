# Requirements Traceability Matrix

## Story: 1.2 - PostgreSQL Database Schema Creation

### Coverage Summary

- Total Requirements: 7
- Fully Covered: 4 (57%)
- Partially Covered: 2 (29%)  
- Not Covered: 1 (14%)

### Requirement Mappings

#### AC1: Schema supports Bangkok dataset structure (134 sensors, 7 floors, 18 months of data)

**Coverage: FULL**

Given-When-Then Mappings:

- **Unit Test**: `src/lib/__tests__/supabase.test.ts::Database Schema Types`
  - Given: TypeScript database types are defined
  - When: Schema operations are performed
  - Then: Type-safe database operations are validated

- **Schema Implementation**: `database/001-core-schema.sql::sensor_readings table`
  - Given: Bangkok dataset requirements (134 sensors, 7 floors)
  - When: Core schema is created
  - Then: Table supports floor_number (1-7 constraint), sensor_id VARCHAR(50), and TIMESTAMPTZ for 18+ months data

- **Schema Validation**: `database/001-core-schema.sql::Constraints and Comments`
  - Given: Database constraints and documentation
  - When: Schema is deployed
  - Then: Floor numbers are constrained (1-7), sensor readings are properly typed, and schema is documented

#### AC2: Optimized indexes for time-series queries with sub-500ms response times for common queries

**Coverage: FULL**

Given-When-Then Mappings:

- **Index Implementation**: `database/001-core-schema.sql::Performance-optimized indexes`
  - Given: Time-series query patterns for sensor data
  - When: Database indexes are created
  - Then: BRIN index on timestamp, composite indexes on sensor_id+timestamp, floor+timestamp, equipment+timestamp are implemented

- **Query Optimization**: `database/001-core-schema.sql::idx_sensor_readings_composite`
  - Given: Dashboard query requirements
  - When: Multi-column queries are executed
  - Then: Composite index (sensor_id, floor_number, timestamp DESC) optimizes common query patterns

#### AC3: Materialized views for daily/hourly aggregations to support dashboard performance

**Coverage: FULL**

Given-When-Then Mappings:

- **Daily Aggregates**: `database/002-materialized-views.sql::daily_aggregates`
  - Given: Executive dashboard requirements
  - When: Daily aggregation view is queried
  - Then: Pre-computed AVG, MAX, MIN, STDDEV, COUNT metrics are available by date/sensor/floor/equipment

- **Hourly Aggregates**: `database/002-materialized-views.sql::hourly_aggregates`
  - Given: Real-time dashboard requirements
  - When: Recent data is needed (7 days)
  - Then: Hourly aggregated data with error counts is available

- **System Health Views**: `database/002-materialized-views.sql::system_health_summary`
  - Given: Monitoring dashboard requirements
  - When: System health metrics are needed
  - Then: Health percentage, active sensors, and error counts are pre-computed

- **Refresh Functions**: `database/002-materialized-views.sql::refresh_all_aggregates`
  - Given: Need for updated aggregated data
  - When: Refresh function is called
  - Then: All materialized views are refreshed concurrently

- **Type Integration**: `src/types/database.ts::Materialized view types`
  - Given: TypeScript type safety requirements
  - When: Materialized view queries are made
  - Then: Type-safe interfaces for all aggregate views are available

#### AC4: Migration scripts for schema updates with rollback capabilities

**Coverage: FULL**

Given-When-Then Mappings:

- **Migration System**: `scripts/setup-database.js::Migration tracking`
  - Given: Need for database versioning and rollbacks
  - When: Migration scripts are executed
  - Then: _migrations table tracks executed migrations with rollback SQL

- **Schema Files**: `database/001-core-schema.sql, 002-materialized-views.sql, 003-rls-policies.sql`
  - Given: Database schema changes
  - When: Migration scripts are run
  - Then: Structured SQL files with proper versioning and dependencies

- **Rollback Support**: `scripts/setup-database.js::recordMigration`
  - Given: Migration execution
  - When: Migration is recorded
  - Then: Rollback SQL is stored for potential schema reversions

#### AC5: Supports multi-tenant data isolation with Row Level Security (RLS)

**Coverage: FULL**

Given-When-Then Mappings:

- **RLS Policies**: `database/003-rls-policies.sql::sensor_readings_select_policy`
  - Given: Multi-tenant access requirements
  - When: Users query sensor data
  - Then: Professional tier gets full access, free tier gets 7-day limited access

- **Subscription Management**: `database/001-core-schema.sql::subscriptions table`
  - Given: User subscription tiers
  - When: User access is validated
  - Then: Subscription tier (free/professional) and status are tracked with user_id FK to auth.users

- **Security Functions**: `database/003-rls-policies.sql::get_user_subscription_tier`
  - Given: User authentication
  - When: Data access is requested
  - Then: User's subscription tier is validated and appropriate access is granted

- **Activity Logging**: `database/003-rls-policies.sql::log_user_activity`
  - Given: User actions need tracking
  - When: API calls are made
  - Then: User activity is logged for rate limiting and analytics

- **Type Safety**: `src/types/database.ts::RLS function types`
  - Given: TypeScript integration
  - When: RLS functions are called
  - Then: Type-safe function signatures are available

#### AC6: Database performance testing validates <10 minute bulk import and <500ms API response times

**Coverage: PARTIAL**

Given-When-Then Mappings:

- **Basic Client Tests**: `src/lib/__tests__/supabase.test.ts::Database Schema Types`
  - Given: Supabase client configuration
  - When: Database operations are performed
  - Then: Client connections and basic queries work

**Coverage Gap**: Missing performance benchmarking tests for bulk import (<10 min) and API response times (<500ms). No load testing or performance validation tests implemented.

#### AC7: Production-ready monitoring and alerting for database health

**Coverage: NONE**

**Coverage Gap**: No monitoring, alerting, or health check implementations found. Missing:
- Database health check endpoints
- Query performance monitoring setup
- Connection pool monitoring
- Slow query alerting configuration
- Database metrics collection

### Critical Gaps

1. **Performance Testing (AC6)**
   - Gap: No bulk import performance tests (10-minute requirement)
   - Gap: No API response time validation tests (500ms requirement)
   - Risk: High - Could fail performance SLAs in production
   - Action: Implement performance test suite with realistic data volumes

2. **Production Monitoring (AC7)**
   - Gap: Complete absence of monitoring and alerting infrastructure
   - Risk: High - No visibility into database health in production
   - Action: Implement health checks, monitoring dashboards, and alerting

### Test Design Recommendations

Based on gaps identified, recommend:

1. **Performance Test Suite**
   - Bulk import tests with Bangkok dataset subsets (1M, 2M, 4M records)
   - API endpoint response time benchmarks
   - Materialized view refresh performance validation
   - Concurrent user load testing

2. **Integration Tests**
   - End-to-end RLS policy validation with actual user sessions
   - Multi-tenant data isolation verification
   - Migration rollback testing

3. **Monitoring Implementation**
   - Health check API endpoints
   - Database connection pool monitoring
   - Query performance logging and alerting
   - Materialized view refresh scheduling and monitoring

4. **Test Data Requirements**
   - Bangkok dataset sample (1000+ records for basic tests)
   - Multi-tenant test users with different subscription tiers
   - Performance test datasets at scale (1M+ records)

### Risk Assessment

- **High Risk**: AC7 (Production Monitoring) - No coverage, critical for production readiness
- **Medium Risk**: AC6 (Performance Testing) - Partial coverage, performance SLAs unvalidated
- **Low Risk**: AC1-AC5 - Full implementation coverage with comprehensive schema and security

### Schema Quality Indicators

**Positive Indicators:**
- Complete TypeScript type integration
- Comprehensive RLS policies with multi-tenant isolation
- Time-series optimized indexing strategy
- Materialized views for performance optimization
- Migration tracking with rollback support

**Areas for Improvement:**
- Missing performance validation tests
- No production monitoring infrastructure
- Limited integration test coverage for complex scenarios

### Implementation Completeness

**Fully Implemented (AC1-AC5):**
- Core schema with Bangkok dataset support
- Time-series optimized indexes
- Materialized views with refresh functions
- Migration system with rollback capabilities
- Multi-tenant RLS policies and security functions

**Partially Implemented (AC6):**
- Basic client configuration tests
- Missing performance benchmarking

**Not Implemented (AC7):**
- Production monitoring and alerting infrastructure
- Health check endpoints
- Query performance tracking

### Next Steps for Full Coverage

1. **Immediate (P0)**: Implement health check endpoints and basic monitoring
2. **Short-term (P1)**: Create performance test suite with Bangkok dataset
3. **Medium-term (P2)**: Add comprehensive integration tests for RLS policies
4. **Long-term (P3)**: Implement advanced monitoring dashboards and alerting